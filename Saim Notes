6/4/2022

Day 65 Streams

day65_streams
____________________________________________________________

Streams
____________________________________________________________

After class: Unit 5 & 6 Assessment
	last topic on this is maps 

Extra topic module on canvas

Java Module Completion Assignment
	https://forms.gle/zYT22Y2g1YJcxCUE8
____________________________________________________________

Stream

	not a data structure
	also added in Java 8 after lambda

	 java.util.stream 

	method that accepts an input from a data structure

	doesn't change the data structures

	the method
		stream() gathers the elements and then allows you to do an action

		or

		Stream.of(array) creates a Stream from an array

	Stream methods:

		distinct(): gets rid of duplicates

		collect(): method to take all elements to allow conversion to another type

			arguments:

				Collectors.toList(): returns elements as a List

			ex: 

				list.stream().distinct().collect(Collectors.toList());

		toArray(): elements are converted to the array

			Arrays.stream(arr).distinct().toArray();

		skip(): allows to skip a certain amount of elements from the data structure
			-> act a little like removing them

			int argument for how many elements will be skipped

			ex: stream().skip(5)

		limit(): only keeps the defined number of elements

			int argument for how many elements there will be total

		map(): allows to change the elements based on given lambda argument

			Function functional interface argument

				ex: 
					map( p -> p * 10)

		filter(): allows to filter the elements, return specific ones

			Predicate functional interface argument

			ex:
				filter( p -> p % 2 == 0)

		count(): allows you to count certain elements

			commonly used with filter:
				ex:
					filter().count()

		forEach(): allow to iterate through the elements

		allMatch(): checks if all elements match the defined lambda

			Predicate functional interface argument
			returns boolean
			ex:
				allMatch( p -> p % 2 == 0) 

		anyMatch(): checks if one element match the defined lambda

			Predicate functional interface argument
			returns boolean

		noneMatch(): checks if no element match the defined lambda

			Predicate functional interface argument
			returns boolean	

____________________________________________________________

Day 64 Functional Interface & Lambda Expression 

day64_functional_interface
____________________________________________________________

Functional Interface
Lambda
____________________________________________________________

Functional interface:
	an interface that defines one abstract method that is implemented by a lambda expression

Lambda Expression: defining a function with no name
	
	() -> {}
	(parameters)  ->  {statements}

Recap of main built in functional interface:

Predicate<T> 
	defines a function that takes one object as the argument and returns boolean

	method: test()

Consumer<T>:
	defines a function that takes one object as the argument and does not return anything

	method: accept()

Function<T, R>:
	defines a function that takes one object(any type) as the argument and returns one object(any type)

	method: apply()

BiPredicate<T, U> 
	defines a function that takes two object as the arguments and returns boolean

	method: test()

BiConsumer<T, U>:
	defines a function that takes two object as the argument and does not return anything

	method: accept()

BiFunction<T, U, R>:
	defines a function that takes two object(any type) as the argument and returns one object(any type)

	method: apply()
____________________________________________________________





Day 63 Functional Interface & Lambda Expression 

day63_functional_interface
____________________________________________________________

Functional Interface
Lambda
____________________________________________________________

Sharing soon:
	
	oca material/ practice quizzes 
	extra topics notes
	study guide unit 5 + 6 - last assessment
	Social Media Solution

Reminder: Polymorphism quiz due tonight

____________________________________________________________

Functional Interface

	not used for inheritance
		-> not inherited
		-> not intend to be implemented to a class to be overridden

	act as function/custom method

	define one abstract method
		-> trying to define more than one abstract method in a functional interface would say a syntax issue

		common names for those methods: test, apply, function

	@FunctionalInterface annotation used before the interface line

	Q: If you don't inherit these interface, how would we implement the abstract method?

		lambda expression

	+ improve code efficiency 
	+ stream methods

Lambda Expression:
	
	functions/method without name	

	instance of the functional interface
		-> allows you to define the implementation of the abstract method

	syntax:

		() -> {};

		(parameters) -> {statements};

		Note: parenthesis for the parameter is only needed if there is more than one parameter
		Note: curly brackets for the statements are only needed if there is multiple lines

____________________________________________________________

Generics

	<> brackets define that any type/object can be used

	T is a common name <T>
	also: U, R (return type)

____________________________________________________________

Functional Interface built in Java:
	
	Predicate
		defines a function that takes one object as the argument and returns boolean

		boolean test(T t)

		-> p is a common name for the argument name in the lambda 

		example we have used:
			removeIf method when we used the lambda to remove the elements

			the parameter of the removeIf method was a Predicate functional interface

	Consumer
		defines a function that takes one object as the argument and does not return anything

		void test(T t)

	ex:
		forEach method from collections takes the Consumer argument


	Function<T, R> 
		defines a function that takes one object(any type) as the argument and returns one object(any type)

			R apply(T t);



Day 62 Maps 

day62_maps
____________________________________________________________

Maps Practice
Enum 
____________________________________________________________

Map

    interface that maintains the key/value pairs

    Entry: key/value pair

        keys must be unique
        values can be duplicate

Class that implement the Map interface

    HashMap: the order is not guaranteed    
        null key is allowed

    LinkedHashMap: insertion order is maintained
        null key is allowed

    TreeMap: implements SortedMap. The entries are sorted by the keys in natural order
        null key is not allowed

    HashTable: the order is not guaranteed 
        synchronized (thread safe)
        does not allow null keys or values

syntax of HashMap

    Map< key, value > name = new HashMap<>();

Looping through map

    We cannot loop directly in the map

    To iterate through a map use 

        keySet(): returns a Set of the keys in the map

        values(): return the Collection of values in the map

        entrySet(): returns the entries in the map

            getKey()
            getValue()
____________________________________________________________

Database

    when you get information from a database you will get the information as a

    List< Map<String, String>> 

    where the  List< Map<String, String>> is an ArrayList that holds Map<String, String> as the elements

    each Map<String, String> is would contain the information about whatever data you are looking at, for example people would have keys of FIRST_NAME, AGE, LOCATION, etc

    so everyone Person would have their information from the database as a key/value pair and the ArrayList holds all those maps

    Example from the code: 

        System.out.println(list.get(0).get("LAST_NAME"));

            this could give the last name from the first person in the ArrayList

        System.out.println("First name: " + list.get(list.size() - 1).get("FIRST_NAME"));

            this would give the first name from the last index of the ArrayList 

____________________________________________________________

Enum: Enumeration

    it is special datatype that is used to define constant variables

Examples:

    enum Direction{
        NORTH, EAST, SOUTH, WEST
    }

    enum Grade {
        A, B, C, D, F
    }

The enum define Fields (variables)

    usually written in uppercase letters since they are constants

Enums act like a class to they have some variables, methods

-- Using the enum 

    -> We can make objects out of our enum 

        LetterGrade grade;
        grade = LetterGrade.A;

    > Note: we can only use fields that the enum has declared
        Doing LetterGrade.H would given syntax error


    -> Enums can also be used with switch statements:

        Ex: 

        switch (grade) {
            case A:
                System.out.println("You got an A!");
                break;
            case B:
                System.out.println("Not bad");
                break;
            case C:
                System.out.println("You could do better");
                break;
            case D:
                System.out.println("Not so good");
                break;
            case F:
                System.out.println("You failed");
        }


Day 61 Maps 

day61_maps
____________________________________________________________

Collection Framework
    Queue
    Iterator

Maps
____________________________________________________________

Queue: 
    child of Collection interface

    interface that follows FIFO: first in, first out

    oracle definition: Queue typically, but do not necessarily, order the elements in a FIFO manner

    PriorityQueue: 
        class the implements the Queue interface
            -> even thought it implements Queue the order of the elements is not based on insertion order

            internally is working with some priority, by default it is in ascending order

    ArrayDeque: 
        class that implements Deque

        usually be faster than stack using LIFO, and faster than a LinkedList used for as a queue

    Deque: interface that defines methods that allows access to the beginning and end of the collection
        child of Queue interface

        -> LinkedList also implements the Deque

        defines methods like: addFirst, offerLast, peekFirst, etc 

    Methods of Queue:

        add()
        remove()
        element(): checks what is at the top of the queue

            -> these methods face an issue there will be an exception thrown

        offer() --> same as add()
        poll()  --> same as remove()
        peek()  --> same as element()

            -> these methods face an issue they will return null

        -> most likely if you want to use FIFO function these methods are useful

____________________________________________________________

Iterable interface

    parent of the Collection interface

    any class that implements the Collection interface can use the iterator, which means it can use a for loop and create its own iterator object

    Iterator object is a way to manually iterate through the elements of the collection one at a time

    method of iterator:

        next(): moves to the next element, and returns it
        hasNext(): check if there is an element after it, returns boolean
        remove(): remove the current element from the collection

    syntax to create the object:

        Iterator<dataType> name = collection.iterator();

____________________________________________________________

Map

    interface that maintains the key/value elements

    does not inherit the Collection interface

    Entry: key/value pair

        keys must be unique
        values can be duplicate

Class that implement the Map interface

    HashMap: the order is not guaranteed    
        null key is allowed

    LinkedHashMap: insertion order is maintained
        null key is allowed

    TreeMap: implements SortedMap. The entries are sorted by the keys in natural order
        null key is not allowed

    HashTable: the order is not guaranteed 
        synchronized (thread safe)
        does not allow null keys or values

    Note: 
        insertion order: the order the elements are added to the collection

        natural order: entries are added and sorted based on the keys
            ascii, small -> large

syntax of HashMap

    Map< key, value > name = new HashMap<>();

methods

    put( k , v): 
        add the entry (key/value) to the map

        -> if the key exist the value will be changed/updated

    get( k ):
        return the value that is related to the given key argument

        Q: What if we get a key that doesn't exist --> null

    remove( k ) 
        remove the entire entry (both key and value) based on the given key argument

    containsKey( k )
        return boolean. checks if the map has the given key argument

    containsValue( v ) 
        return boolean. checks if the map has the given value argument

    keySet(): returns a Set of the keys in the map

    values(): return the Collection of values in the map

    entrySet(): returns the entries in the map

        getKey()
        getValue()


Day 60 Collections 

day60_collections
____________________________________________________________

Collection Framework
    Collection
    Stack
    Queue
____________________________________________________________

Collection Framework: a group of interfaces and class that define how data structures will handle data

    -> only work with objects, not primitive types   

main interfaces:

    collection: the parent of all other collections types. this interface defines the most common action(methods) that a collection should have

        Ex: add, remove, size

    list: ordered(index), allows duplicates

    set: unordered(no index), does not allow duplicates

Classes that implement the List interface:

    ArrayList: data structure that uses arrays internally. Resizable array

        -> useful for storing/reading information

        -> faster than Vector, because ArrayList is not synchronized

    LinkedList: data structure that uses nodes internally

        -> Node: an object that has the element, the reference of the previous node, and the reference of the next node

            ex:     node{
                        element
                        previous
                        next
                    }

        -> useful for manipulating data

    Vector: legacy version of ArrayList, it uses array internally, but its synchronized

        synchronized(thread safe): multiple threads cannot access at the same. if there is multiple threads they will go one a time

            ex: atm -> you want to access to atm one a time, so it is thread safe
                if the atm was not thread safe then multiple people(threads) can interact at the same time -> that could cause problems like over drafting

        - useful for thread safety

    Stack: data structure that following last in, first out
        see below for details about the Stack

Classes that implement the Set interface:

    HashSet: data structure that uses HashMap internally. Hashing algorithm, which means its handles data fast and efficiently 

    LinkedHashSet: data structure that has hash table and linked list implementation. Insertion order is maintained

    TreeSet: implements the SortedSet interface. Elements are stored in their natural order(sorted)
        -> cannot have null element

What is the advantage/purpose of the collection framework

    these data structures all define different ways to handle and use data
    there is different implementation/algorithms to solve a problem

    -> performance of an action:
        different collections can have different performance for different actions:
            ex: adding, removing, editing, searching

What is the advantage of the polymorphic references

    polymorphic references, especially the interface reference of the objects allows flexibly with methods, return types, and constructors 

    example: constructor of the collection type objects have the parameter of collection, it means any object that has is a relation with the collection interface can be used to call that constructor

        -> it means you can make an ArrayList from a HashSet object
            or a TreeSet from an ArrayList

    ex of method:

        public static List<> method()

            -> this method can return any object that implements the List

        public static void method(List<>)

            -> this method can be called by given an argument of any object that implements the List

Stack

    LIFO: Last in, First out

        ex:

            Book1

            add another book:

            Book2
            Book1

            add another book:

            Book3
            Book2
            Book1

            so right now if you wanted to remove a book from the stack it would be Book3 because it was the most recent added to the stack

    methods for LIFO:

        push(): add the element to the top of the stack
        peek(): return the element at the top of the stack. does not remove it, only lets you see what there
        pop(): remove the element at the top of the stack, and returns it

    difference between push vs add:
        functionality is the same, add elements to the stack

        add method (from collection interface) returns boolean

        push method (from stack) returns the object it added

Queue

    interface that follows FIFO: first in, first out

        -> think of a line of people. first person in line will get helped first

    classes that implemented Queue:

        PriorityQueue: data structure stores elements randomly. null is not allowed

        ArrayDeque: implements Deque interface

            Deque interface: allowing access to elements from the beginning and the end

                -> LinkedList is also implementing this interface

    methods:

            add()     <---->  offer()

            remove()  <----> poll()

            element() <----> peek()

        the methods on the left side: add, remove, element will cause an exception if they are not used correctly. 

        the methods on the right side: offer, poll, peek will return null


Day 59 Collections 

day59_collections
____________________________________________________________

Collection Framework
    Collection
    List
    Set
____________________________________________________________

Collection Framework: a group of interfaces and class that define how data structures will handle data

    -> only work with objects, not primitive types   

main interfaces:

    collection: the parent of all other collections types. this interface defines the most common action(methods) that a collection should have

        Ex: add, remove, size

    list: ordered(index), allows duplicates

    set: unordered(no index), does not allow duplicates

Classes that implement the List interface:

    ArrayList: data structure that uses arrays internally. Resizable array

        -> useful for storing/reading information

        -> faster than Vector, because ArrayList is not synchronized

    LinkedList: data structure that uses nodes internally

        -> Node: an object that has the element, the reference of the previous node, and the reference of the next node

            ex:     node{
                        element
                        previous
                        next
                    }

        -> useful for manipulating data

    Vector: legacy version of ArrayList, it uses array internally, but its synchronized

        synchronized(thread safe): multiple threads cannot access at the same. if there is multiple threads they will go one a time

            ex: atm -> you want to access to atm one a time, so it is thread safe
                if the atm was not thread safe then multiple people(threads) can interact at the same time -> that could cause problems like over drafting

        - useful for thread safety

Classes that implement the Set interface:

    HashSet: data structure that uses HashMap internally. Hashing algorithm, which means its handles data fast and efficiently 

    LinkedHashSet: data structure that has hash table and linked list implementation. Insertion order is maintained

    TreeSet: implements the SortedSet interface. Elements are stored in their natural order(sorted)
        -> cannot have null element

Tomorrow:
    What is the advantage of the collection framework
    What is the advantage of the polymorphic references



Day 58 Exceptions 

day58_exceptions
____________________________________________________________

Exceptions hierarchy 
throws vs throw
____________________________________________________________

day58_exceptions

Exceptions

	issue that stops the normal flow of execution 

Error
	
	problem not related to code

Throwable is the parent of Error and Exception classes

Exception class:
	
	Parent of all exception types

	-> direct child classes are checked exceptions:
		 exceptions that must be handled in compile time

RunTimeException class:

	child of Exception

	-> child classes of the RunTimeException are unchecked, so they occur during runtime

	Example of IndexOutOfBoundsException

           possible references for IndexOutOfBoundsException

             IndexOutOfBoundsException obj =  new IndexOutOfBoundsException();

             RunTimeException obj =  new IndexOutOfBoundsException();
             
             Exception obj =  new IndexOutOfBoundsException();

Rule for multiple catch blocks:

	when you define multiple catch blocks the Exceptions should be the most specific in the beginning and become more general as they go down

	ex:
        try{

        } catch (IndexOutOfBoundsException e){

        } catch (RuntimeException e){

        } catch (Exception e){

        }

throws

	added to a method signature to allow the program to compile

	-> doesn't handle the exception but allow compiling. If the exception condition is met the exception will still be thrown and the program will stop

	-> useful to ignore checked exceptions

throw

	how exceptions are thrown(caused)

	throw an exception object

	syntax:

		throw new ExceptionType();

difference between try/catch vs throws

	try/catch -> handle exceptions. Define the set of statements that should be executed if a specific exceptions happens

	throws: allowing the program to compile and if exception happens the program still stops

day58_exceptions.bank

Custom Exceptions
	-> we did for practice to understand how exceptions work

	we made a class 

		inherited the RuntimeException class we made an unchecked exception

		inherited the Exception class we made a checked exception

	call the super constructors to assign the messages

	when we created/throw a checked exception, as the person creating the class/object/file, I did not want to handle it, I wanted the users to handle the exception, so we used throws to ignore the exception, allowing the code compile

Day 57 Exceptions 

day57_exceptions
____________________________________________________________

Exceptions
try/catch
finally
throws
____________________________________________________________

day57_exceptions.webelement

day57_exceptions.learn

Exceptions

	What is an exception:
		something that stops the normal flow of the program. Some problem in the code

	What are the 2 types of exception:

		checked (compile time): exception that must be handled in order to compile

			Ex: Thread.sleep()

		unchecked (runtime): exception that happen after the program is run. You can handle unchecked exceptions, but you don't need to

		compile time: while compiling

		runtime: when you execute

	How do you handle exceptions:

		with try catch 

		try block defined any code that will be execute top to bottom and if any exception occurs in from the code in the try block it can be caught and handled in the catch block. The catch block defined the code that will run if an exception occurs

		Ex: try{
			WebDriver driver = null;
			driver.get("google.com");
		} catch(NullPointerException e){
			System.out.println("No Object Created");
		}

		-> Remember the 'e' is just a name/reference so it can called anything, but 'e' is commonly used for exceptions

	Common exceptions you faced?

		NullPointerException, IndexOutOfBoundsExceptions, NoSuchElementException, StaleElementException

	What is an error?

		stops the normal flow of execution, but errors are issues not directly related to the code

		you might not be able to handle/fix it

		ex: memory issue, internet, issue, environments

	multiple catch blocks

		it is possible to have multiple catch blocks to handle different kinds of exceptions

		-> Note: you want to make the exceptions as specific as possible to not allow anything that you did not intend

		rule: order of the catch blocks does matter. The Exceptions should be most specific at the top and become more general towards the end

	finally block:

		its optional to add to try/catch

		this code block will run no matter, if there is an exception or not

		- common use case:
			helps to close and shut down properly. 
				Ex: Scanner close the object 
					File is open -> File closes properly so there is no issue

	ex: 

	    Scanner input = new Scanner(System.in);

        try {
            System.out.println("enter a number");
            int num = input.nextInt();

            System.out.println("enter number 2");
            int num2 = input.nextInt();

            System.out.println(num/num2);

        }catch (InputMismatchException obj){
            obj.printStackTrace(); // shows the exception message in the console
        }catch (ArithmeticException e){
            System.out.println(e.getMessage());
        } finally {
            System.out.println("FINALLY BLOCK");
            input.close();
        }

	Exception as object
	
		Exceptions are object which means there is methods that can be used

			-> 'e' is a common name for the Exception object in the catch blocks

			useful methods:
 
				printStackTrace():	void
					outputs the full exception message to the console

				getMessage(): return String
					display the message of an exception, which is usually defined by the exception

		Ex:

        try {
            System.out.println("Start");
            Thread.sleep(-2000);
            System.out.println("Finish");
        } catch (Exception e) {
           e.printStackTrace();
           System.out.println(e.getMessage());
        }

        printStackTrace():	
			java.lang.IllegalArgumentException: timeout value is negative
				at java.base/java.lang.Thread.sleep(Native Method)
				at day57_exceptions.learn.FourthTry.main(FourthTry.java:8)

		getMessage():	
				timeout value is negative

____________________________________________________________

Todo:

	Social Media Task
	Abstraction Short quiz - due May 17th 11:59 EST
	Exceptions Short Videos
	Start to take a look at interview q/a videos


Day 56 Polymorphism 

day56_polymorphism
____________________________________________________________

OOP: Polymorphism
____________________________________________________________

Objects

	String str = "Java";

	String str --> reference 

	"Java" --> object

	--

	Scanner input = new Scanner(System.in);

	Scanner input  --> reference
	new Scanner(System.in); --> actual object that the methods we can 

Polymorphism

	objects being able to have different references 

possible references of an object

	- itself: reference is the same class that the object was made from
	- any super class: any class where there "is a" relation(both direct and not direct parents)
	- interface: any interface that is implemented to the class

** Note: Execution will happen on the object. That means the implemenation from the object will be run
	A reference must have accessibility to the method/variable

	--> dynamic binding: execution happens from the overridden implementation of the object
		runtime

day56_polymorphism.book

Reference type casting

	you can cast the references of an object to other types as long as there is a relation

	upcasting: going from the child class to a parent class 

		automatically/implicitly 

	downcasting: going from a parent class to a child class

		manually/explicitly  

Use case:
	
	WebDriver driver = new ChromeDriver();

	you run tests, if a test fails you would want to take a screenshot and add it to the report

	((ChromeDriver)driver).takeScreenshot()

instanceof

	operator that helps to determine the type/class of an object

	general syntax: 

		object instanceof className/type

	statements returns a boolean

		if the object is the type of the className/type it returns true
		otherwise it would return false

	Ex:

		Animal 

		Dog extends Animal

		new Dog() instanceof Animal --> true

		new Dog() instanceOf String --> false

day56_polymorphism.cars

One benefit of Polymorphism: 

	with methods:

	Polymorphism allows our methods to be flexible to work with many classes if they share IS A relation

	+ having a super class as the parameter means any class that inherits that class can be given as the argument of that method

	+ having a super class as the return type means any class that inherits that class can be returned 


Day 55 Polymorphism 

day55_polymorphism
____________________________________________________________

Interface
OOP: Polymorphism
____________________________________________________________

day55_polymorphism.shopping

	Inheritance between:

	class -> class
		extends

	interface -> class
		implements

	interface -> interface
		extends

inheritance in interface
	
	interface is not a class, it does not follow the same rules as classes

	in java a class cannot have more than 1 direct parent class

	but a class can implement as many interfaces as it wants

	Ex:

		Cat extends Animal implements Playable, Petable

		Tiger extends Animal implements Swimmable

		Cow extends Animal implements Consumable, Petable

		Shark extends Animal implements Swimmable, Consumable

		Duck extends Animal implements Playable, Swimmable, Consumable, Petable

	public interface Aqua extends Swimmable, Consumable {

	}

	Shark extends Animal implement Aqua

	Duck extends Animal implement Playable, Aqua

	public interface isFriendly extends Playable, Petable {

	}

	Duck extends Animal implement isFriendly, Aqua // same as line 41

methods in interfaces

	day55_polymorphism.interface_methods

	able to create 3 types of methods in an interface

	abstract methods: any method created will be abstract by default

	static method: a method that has implementation in the interface
		static: access by the interface

			-> not inherited to the class that implement

	default method: a method that has implementation in the interface
		instance for the classes that implement 

	Note: static and default methods were added in java 8

abstract class vs interface

	Both: 
		can't objects
		can create abstract methods
		can create static methods
		can be inherited (class to class and interface to interface)
		create an is a relation

	Abstract class:
		can have constructors
		can have instance variables
		can have blocks (static block)
		can use any access modifier on any variables/method
		class can only have one parent

	interface:
		public access modifier on variables/method by default
		methods created here are abstract by default
		only has static final variables
			no instance variables
		can create default methods
		static methods are not inherited
		not a class, so more flexible for inheritance. A class can inherit as many interfaces as needed and an interface can inherit as many interfaces 

Note: java 9 added ability to use private and protected access modifiers
____________________________________________________________

Polymorphism 

Objects and References

	public interface Driveable {}

	public class Street implements Driverable{
		
	}

	Street obj = new Street();

		Street obj --> reference
		new Street(); --> object

	Street obj2; --> only a reference

	Street obj3 = null; --> no object here

	new Street(); --> object with no reference

Polymorphism 
	
	the object taking different forms

	an object is able to take different form by the reference

	** what are the possible references of an object?

		- itself: the reference is the same type as the object
			Street obj = new Street();

		- any super class: any direct or indirect super class can be the reference	
			Object obj = new Street();

		- any interface that is implemented
			Driveable obj = new Street();

	the reference of an object must have access to the variable or method, otherwise the code will not compile

	the execution happens on the object side
		ex: if a method is overridden the implementation of the object is executed

WebDriver driver = new ChromeDriver()

WebDriver driver = new FireDriver()

day55_polymorphism.animal
day55_polymorphism.clothes



Day 54 Abstraction

day54_abstraction
____________________________________________________________

OOP: Abstraction
Abstract Class
Interface
____________________________________________________________

Abstraction 

	concept that allows us to hide the implementation of a method, meaning we can create ideas/actions without worrying about how those idea or action are done

	create methods that have no implementation

		-> This allows us to establish common methods that would shared with multiple classes/object but not having to worry about what the methods does

	abstraction in java

		1) abstract class
		2) interface

Abstract class

	class that has the abstract keyword 

	ex: public abstract class Example {}

	- abstract classes can make abstract methods

	- abstract classes cannot be instantiated (cannot create object of the class)

		cannot do: Example obj = new Example();

Abstract method:

	a method without a code body ( no implementation )

	-> these methods must be overridden (implemented) in the sub classes that inherit them

	ex: public abstract int getNumber();

concrete class:

	first non-abstract(normal) class which must override all abstract methods from any super classes or interfaces

	-> reasons: normal classes cannot have abstract methods, so if any abstract method is inherited it must be implemented

day54_abstraction.animal

day54_abstraction.creating

day54_abstraction.language

____________________________________________________________

Interface

	another way to make abstract methods

	they will be declare with keyword interface, instead of keyword class

	public interface Go {

	}

	-> Note: the interfaces are made in .java files, so the interface name will match the .java file name

	method created in an interface are public abstract by default

	variables created in an interface are public static final by default

	-> no instance members in an interface

	Interface are not the class, there is no constructor, no blocks

	How to use an interface

		when you go from an interface to a class, use keyword implements

In java we cannot have more than one direct parent

The interfaces are not a class, so they do not follow the same rules, and so we are able to implement multiple interfaces to one class



Day 53 Abstraction

day53_abstraction
____________________________________________________________

OOP: Abstraction
Abstract Class
____________________________________________________________

OOP: principles that help design our classes and organize code in a way so that its reusable and maintainable 

Encapsulation: data hiding, used to protect the information by using private keyword and allowing indirect access to those variables with public getters and setters

Inheritance: passing information from one class to another. The class that gives the information is called the ( Parent/Super/Base ) and the class that gets the information is called the ( Child/Sub/Derived ) class

How does Encapsulation work with Inheritance?

    private information does not get inherited to child classes, does it means we cannot use Encapsulation with Inheritance?

    We can use them together because even if the variables cannot be inherited directly to the child, the child class will inherit the public getters and setters that will allow the variable be assigned to and to read from

____________________________________________________________

Abstraction 

	concept that allows us to hide the implementation of a method

		focus on what the method does, not how it does it

	implementation: the code, the actions the method do

	abstraction cannot exist without inheritance

How to achieve abstraction in java

	1) abstract class
	2) interface

Abstract class:

	a class that uses the keyword abstract

	public abstract class hello {

	}

	able to define abstract methods

	not able to create objects of this class

Q: Can you create an object of a abstract class, even if there is no abstract methods created?

	no, abstract class can never create objects of it

Q: Can you have non-abstract methods in abstract classes

	yes, you can define any number of abstract or non-abstract methods

Abstract method:

	a method without any implementation (no code body)

	public abstract void eat();

day53_abstraction.cars

concrete class: 
	
	first non-abstract class (normal class) that inherits abstract methods

	the concrete classes must implement all abstract methods

day53_abstraction.exercise



Day 52 Inheritance 

day52_inheritance 
____________________________________________________________

final keyword
static in inheritance
____________________________________________________________

Practices Today:
Color, Book, TJMaxx Replit
Unit 5 Problem Set
Abstraction Short Video

Later:
Cities Project
Encapsulation & Inheritance short quiz
____________________________________________________________

Method Overriding

	changing the implementation/code of a method that is defined and inherited in a super class

	why do we need overriding? 
		define a more specific method for the sub classes

Q: What is the difference between overloading and overriding

	overloading is to change the number or type of parameters to allow another method with the same name and this happens in the same file

	overriding is changing the implementation of the method between a super and sub class, so the method in the sub classes works differently for the sub class objects
	
____________________________________________________________

final keyword
	
	not being able to change

	final variable:  variable that cannot be changed, after it has a value it cannot be reassigned

		Ex: final int a = 5;
			a = 10; // this will give problem

		Q: What are constants?

			static final variables. Information that cannot be changed. Can be access anywhere by class name

			Ex: Math.PI

		Note: Convention for constant variables is to define the name in all uppercase

	final method: method that cannot be overridden, which means you cannot change the implementation

		Q: Can you overload a final method

			yes, you create a method with the same name and different parameters

	final class: this class cannot be the parent of another class

		Q: Can a final class be a child class

			yes, at least it will be the child of the Object class

day52_inheritance.final_example

How to access anything in IntelliJ
	
	hover over + press command/control + click on highlighted item

Can you have multiple classes in a file

	yes, but the public class must match the .java file name

	you should only have 1 public class in a file

day52_inheritance.hiding

Q: Can you override static methods?
	
	No, you cannot override static method, They will become hidden

	You will have access to both methods, the original one in the parent class (hidden) and the new one you make in the child class

	instance method: we can override which means we can change the implementation

	static methods: we cannot override

		if we create a static method with the same name the parent class method will become hidden

Q: Can you override variables

	No, but you can hide them

	If you declare a variable in the child class which was also declare in the parent class, then the parent class variable will be hidden



Day 51 Inheritance

day51_inheritance 
____________________________________________________________

OOP: Inheritance
Protected keyword
Method Overriding
final keyword
____________________________________________________________

Sunday: Off
Monday: Alumni sessions start
	DO NOT join regular class
____________________________________________________________

Constructor in inheritance 

	constructor is not inherited

	- The sub class constructor must still call the super class constructor 

super
	
	reference of the parent class objects

	-> just like this keyword is the reference of the current instances

	super(): call the parent constructor

	this(): calls a constructor in the same class

	super vs super()

		super is the reference of a parent object
			instance variables, instance methods

		super(): constructor calling

Object class:

	parent of all other classes in java

	this is where toString method is defined

When you created a new java class/file, these were the things there:

Tester.java

	import java.lang;

	public class Tester extends Object {

		public Tester(){
			super();
		}

	}

Note: Remember that creating a constructor gets rid of the default constructor, so you must handle the rules about calling the parent class constructor

What you see:

Tester.java

	public class Tester {


	}

day51_inheritance.app 

Inheritance relationships

	Java does not support multiple inheritance

		A class cannot have more than one parent

	Single level inheritance: relationship between two classes

		public class Animal {}

		public class Cow extends Animal {}

	Multi level inheritance: relationship between more than 2 classes. One parent inherits to another class, which becomes the parent of other classes, etc

		public class Person {}

		public class Employee extends Person {}

		public class Tester extends Employee {}

	Hierarchical inheritance: relationship between more than 2 classes. One class is the parent of all other classes

		public class Season {}

		public class Winter extends Season {}

		public class Summer extends Season {}

		public class Spring extends Season {}

Access modifiers with Inheritance 

	(most visible -> least visible)

	public: inherit to anywhere in the project

	protected: protected members are directly accessible in the same package and by sub classes in any package

		-> inherit anywhere in the project

		-> direct access, only in the same package

		with no inheritance, protected works like default

	default: inherit only within the same package

	private: cannot inherit, because private makes everything accessible only in the same class


day51_inheritance.access.a
day51_inheritance.access.b
day51_inheritance.shapes
day51_inheritance.lyft

Method Overriding

	changing the implementation(code) of a method that is defined in the super class

		-> simpler way to say: after inheriting a method we can change how it works

	Uses of overriding: able to define method/action that can become more specific in child class

		-> used much more in abstraction

@Override

	this is an annotation
	makes sure the method is being overridden correctly
	it is optional, but in general recommended to use

Method overriding rules:

    - method needs to be inherited
    - the method signature needs to be same 
    	method signature: name and parameters
    - access modifier can stay the same, or be changed to more visibility, but not less

        public > protected > default > private

        ex: 
            String getName(){
        		return "name";
    		}

    		at this moment the getName() method is default, so it is possible to override and change the access modifier to public or protected, because they are more visible

    - return type: must be the same

    - overriding is for instance methods

IQ: What is the difference between method overloading and overriding

    overloading: have a method with the same name, different parameters 
        -> happens in the same class

    overriding: changing the implementation of a method that comes from a super class
        -> happens between the super and sub class

    summary:
    	Method overloading is used to create multiple ways to call and use a method by changing the parameters. It allows more methods to be created with the same name, but different inputs. Method overriding is for changing the implementation of a method that was inherited from a super class and allowing to be more specific for the sub class objects


Day 50 Inheritance 

day50_inheritance 
____________________________________________________________

OOP: Inheritance
____________________________________________________________

creating sub-packages:

day50_inheritance.book
day50_inheritance.computer

	today we used the above two packages to work
	the day50_inheritance was the base package and putting a dot with a package after allowed us to create a sub package (package inside of the package)

	so doing day50_inheritance.book directly in the src created the base day50_inheritance package with the book sub package inside

	then later we did day50_inheritance.computer which made another sub package, computer, in todays back package: day50_inheritance

constructor with inheritance

	- constructor is not inherited

	- the child class constructor must always call the parent class constructor

	-> using super() we can call the parent constructor

	-> default constructor always called super() in the first line 

	the rules of super() are the same as this()

Q: What is the difference between this vs super

	this: reference of the current object

	super: reference of the parent class object

Q: What is the difference between this() vs super()

	this(): used to chain the constructor in the same class

	super(): used to call the parent constructor from a different class

Object class

	the parent of all classes

	located in the java.lang package

	- doesn't need to be defined, it is automatically inherited

	this is were the toString method is coming from

____________________________________________________________

- Take a look at the Book class from today

	we originally had String author
	but this was only a String type so it could only have characters
	We made a separate Author class, so be able to define the information of an Author better
	That allowed us to replace the String author with Author

		-> Author author 
			becomes an instance variable, it belongs to the objects of the class, which were Book objects

	summary: Give us more information about the author besides just a name 



Day 49 Inheritance 

day49_inheritance 
____________________________________________________________

OOP: Inheritance
____________________________________________________________

Inheritance 

	allows a class to inherit(get) information and actions from different classes

		define a general class --> go to a more specific class

	+ provide code re-usability and maintainability 

	+ a good way to organize and group common information and actions

Names of class with inheritance

	parent == super == base

	child == sub == derived

How to inherit in java

	we use extends keyword on the class we want to inherit to

How inheritance works
	
	pass the information and actions from the parent class to the child class

	Ex: 

		public class Planet {
			int distanceFromSun;
		}

		public class Earth extends Planet {

		}

	Planet is the super class
	Earth is the sub class

	The Planet class will pass its information to the Earth class

Is A Relations

	Inheritance creates is a relation between classes. It is a way to describe how the classes are related to each other

	generic syntax:
		child is a parent
		sub is a super

	Earth is a Planet

What is inherited?

	- all public variables and methods
	- all protected variables and methods
	- default variables and method when the classes are in the same package

What is not inherited?

	- constructors 
	- all private variables and methods
	- default variables and method when the classes are not in the same package


Day 48 Encapsulation

day48_encapsulation
____________________________________________________________

OOP: Encapsulation
OOP: Inheritance Intro (Maybe or static import)

Unit 4: April 22 - April 26
____________________________________________________________

access modifiers

	controlling the access of data and actions

	public: accessible anywhere in the project 
	default: accessible only within the same package
		(no other access modifier was applied)
	private: accessible only within the same class

	Q: Can local variable have access modifiers

		local variable belong the code block they are created, so no you can't use access modifiers with local variables

	What can you use access modifiers on:

		variables, methods, and constructors can have any access modifier

		classes: public and default

	Ex:

		Paper.java

		package p1;

		public class Paper {

			public void write() {}

			void fold() {}

			private void mail() {}

		}

		Main.java

		package p1;

		public class Main {

			public static void main(String [] args){
				Q: What do you have access to here
			}

		}

		access to: 
			write() because it is public
			fold() because it is default and we are in the same package

		don't have access to:
			mail() because it is private so it can't be access outside of the class

		--------------------

		Other.java

		package p2;

		public class Other {

			public static void main(String [] args){
				Q: What do you have access to here from Paper class
			}

		}

		access to: 
			write() because it is public
			
		don't have access to:
			fold() because it is default and we are not in the same package
			mail() because it is private so it can't be access outside of the class

Q: How can you access any of the methods?

	They are instance methods, so you must make objects to use them

OOP Concepts

	Object Oriented Programming

	Encapsulation
	Inheritance
	Abstraction
	Polymorphism 

Encapsulation: 

	a concept that allows us to protect our information from direct access and allows us to define and limit how the information should be used

	How to achieve encapsulation in java:

		add private access modifier to the variables

			-> this stops anyone can using the variable outside of the class

		create getters and setters methods

			-> these methods allow you to access and use the information, but in a protected way

			getters: method to give the value of your variable

			setters: method to change the value of your variable

Ex:

	public class Water  {

		private int oz;

		public int getOz(){
			return oz;
		}

		public void setOz(int oz){
			this.oz = oz;
		}

	}

Sub package

	package inside of a package

	you can create a sub package 2 ways

		right click on src -> new package
			type existing package name and add a period (dot)
			type the sub package after the dot
		or

		right click on current package -> new package 
			current package name will appear with a dot at the end
			type the sub package after the dot


Static imports

    allows you to use specific static members from a certain class without the class name

    Arrays.sort() -> sort()

    syntax:

        import static packageName.className.staticMember -> specific static member

        import static packageName.className.* -> all static members in this class

        Ex: import static java.util.Arrays.sort;
            import static java.util.Arrays.*;


Day 47 Encapsulation

day47_encapsulation
____________________________________________________________

Static
Access Modifiers
OOP: Encapsulation
____________________________________________________________

Static

	static members

		variables: data that will be shared with all objects of the class

		methods: action/code block that has some purpose not related to an object. It is usually a useful action to be called anytime. We don't need objects to call these methods

		block: block of code in the class that is executed when the class is used for the first time

			--> can be used to execute any code that used in the class. (Set up)

			static {

			}

		class: lets not worry about it

	Static members belong to the class not the objects

		instance: objects
			-> each object gets a copy of the instance members

		static: class
			-> one copy of the members

		-> access the members by the class name, which also means you don't need any object to use these members

Access Modifiers:

	keywords used to define the scope or visibility, where you can use/ access the variables, methods, etc

	[Most Visible] public  -> protected  -> default -> private [Least Visible]

	public: access everywhere in the project
	default: access within the same package
		-> when there is no other access modifier

	private: access only in the same class

	protected: we will talk about later

the java file name must match the public class name


What is OOP?

	Object Oriented Programming

	OOP concepts

		Encapsulation
		Inheritance
		Abstraction
		Polymorphism 

What is encapsulation?

	encapsulations allow you to hide your information from direct access. We are able to limit the access to variables by using the private keyword and allowing PUBLIC getters and setters

	getter: method used to see the value of that specific variable

	setter: method used to change/resign the value of that specific variable

Ex:
	
	public class Pen {

		private String brand;

		public String getBrand(){
			return brand;
		}

		public void setBrand(String brand){
			this.brand = brand;
		}

	}

class: Pen
instance variable: brand
	-> private access modifiers makes brand only available in the class

getter:

		public String getBrand(){
			return brand;
		}

		the get method returns the value of the brand. It is how you can access the brand variable anywhere

setter:

		public void setBrand(String brand){
			this.brand = brand;
		}

		the set method will accept a parameter and assign the instance variable from the value in the parameter. Void method because we don't return anything



4/13/2022

Day 46 Custom Classes

day46_static
____________________________________________________________

Custom Classes
Static
____________________________________________________________

Static

	instance: belongs to the object
		every object has its own copy of the members

	static: belongs to the class
		there is a single copy of the members shared with the class, and all objects of that class

	Ex:

		public class Water{

			int amount;

			static String planet = "Earth";

		}

class: Water
instance variable: amount
static variable: planet

Static members:
	variables
	methods
	blocks
	class

To access any static member use the className.static

Note: Objects of a class can access the static members, but it is not recommended

		Water obj = new Water();
		Water.planet; --> proper way to access this variable
		obj.planet; --> works, but not recommended

Static methods:

	methods: doing some actions

	static method: you can do the actions without needed an object. Use just the class name
		-> there is a single copy of this method belonging to the class

		ex:

			Arrays.toString()
			Arrays.sort()
			String.join()

		Use case: utility classes, group useful methods into one file
			Ex: Arrays, Collections

	instance method: you must create an object in order to use these methods. Accessed by the object
		-> every object has a copy of this method

		ex:

			new Scanner().nextInt()
			String s = "java";
				s.charAt()
				s.length()

Static block

	code block that will be executed once in the beginning when the class is used for the first time

	static {
		// code
	}

	can be used to initialize static variables


4/11/2022

Day 44 Custom Classes

day44_custom_classes
____________________________________________________________

Custom Classes
Constructor 
____________________________________________________________

Constructor 

	a special method that is executed when the object is created
	does not have a return type
	run one time
	usually used to initialize the object, set the initial values to the instance variables

	public class Paper{

		public Paper(){

		}

	}

class: Paper

constructor:

	Paper(){

	}

calling the constructor to create an object

	new Paper() --> this creates an object of the Paper class and it does this by calling the constructor from that class

overloading the constructor
	
	create multiple constructors in a class by making different constructors with different parameters

	-> this means you create different ways to make the objects of the class

this keyword

	it is a reference to the objects/instance of the class 

	mainly used to tell the compiler the difference between a instance variable and a local variable

		-> java prioritizes the local variables

	any variables made in a method, loop, if statement etc, is a local variable which belongs to that code block. It is available to use until the close bracket

	instance variable belonging to each object. Make object to use those variables

constructor chaining

	constructor calling another constructor in the same class

	this()

	helps to reduce repetition

	rules:

		- constructor call must be on the first line
		- cannot do more than one constructor call
		- constructor cannot call itself or contain itself
			-> the constructor that is called should not call back to current constructor 
		- this() can only be used in a constructor 

this vs this()

	this: reference to instance members: instance variable and instance methods

	this(): call another constructor 

4/10/2022

Day 43 Custom Classes

day43_custom_classes
____________________________________________________________

Custom Classes
____________________________________________________________

A class is a blueprint/template for objects

A class can define data or actions

	data: instance variables
	action: instance methods

An object is an instance of a class
	physical copy of a class

	creating an object is called instantiation

instance members belong to objects
	do not have static

instance variables
	every object will have a copy of the instance variables

	memory: objects are created in the heap

	instance variables have default values

toString()

	a method that allows us to print our objects 

	the method returns a String that is made of the information of a method

	this method is called automatically when printing
		by default the objects print the memory location

Example class and object

Room.java
	public class Room {

		int doors;
		boolean hasFan;
		double length;
		double width;

		public void goToRoom(){
			// code
		}

		public String toString(){
			return "Room has " + doors + " doors.";
		}

	}

Class: Room
instance variables: doors, hasFan, length, width
instance methods: goToRoom, toString
toString(): will print how many doors the room object has

UseRoom.java
	public class UseRoom {

		public static void main(String [] args){
			Room livingRoom = new Room();
			livingRoom.doors = 4;
			livingRoom.instanceVariable; // general syntax
			livingRoom.instanceMethod(); // general syntax
			System.out.println(livingRoom);
		}

	}

Object reference: Room livingRoom
Actual Object: new Room();
Accessing instance members:
	livingRoom.instanceVariable;
	livingRoom.instanceMethod();

When printing the object directly: 
	System.out.println(livingRoom); --> Room has 4 doors

	-> If we did not make our own toString() in the class then we would see only some memory information

____________________________________________________________

Constructor

	a special method that is called when the objects are created
		-> constructors do not have a return type

	syntax:

		public ClassName(){

		}

	constructor is used with the new keyword to create objects

		Ex:
			new ClassName() --> calls the constructor from the class

			constructor is called once when object is created

	one of the main uses of a constructor is to initialize the instance variables of an object
		-> sets up an object when being created

	if no constructor is made manually, then the compiler has a default constructor that has no arguments
		-> if you make a constructor the default constructor is not there anymore

	Item.java
		
		public class Item{

			String name;
			double price;

			public Item(String inputName, double inputPrice){
				name = inputName;
				price = inputPrice;
			}

		}

class: Item
instance variables: name, price
constructor: 
	public Item(String inputName, double inputPrice){ }

		-> in this example has 2 parameters
			inputName and inputPrice are local to the constructor 

assigning the value to the instance variable from the parameters
			name = inputName;
			price = inputPrice;

	UseItem.java

		public class UseItem{

			public static void main(String [] args){

				Item item = new Item("Pen", 1.5);

			}
		}

class: UseItem
creating an Item object with reference: Item item = new Item("Pen", 1.5);
		
	 new Item("Pen", 1.5); -> creating an object

	 	calls the Item constructor with 2 arguments

	 	The order of the arguments matters. 
	 	"Pen" is the value used for inputName
	 	1.5 is the value used for the inputPrice
____________________________________________________________

this keyword

 	it is a reference to the object/instance

 	mainly it used to tell the compiler the difference between local variables and instance variables

 	when there was variables in different levels, with the same name, java prioritizes the local variables

public class Address {

    String street;
    String city;
    String state;
    String zipcode;

    // unique parameter names

//    public Address(String inputStreet, String inputCity, String inputState, String inputZipcode){
//        street = inputStreet;
//        city = inputCity;
//        state = inputState;
//        zipcode = inputZipcode;
//    }

// 	same parameter names as instance variables

    public Address(String street, String city, String state, String zipcode){
        this.street = street; // assigning the value of the local street from the parameters to the instance variable street
        this.city = city;
        this.state = state;
        this.zipcode = zipcode;
    }

}

____________________________________________________________

Constructors can be overloaded

	overloading means to have different parameters

	enables you to create objects in different way and with different data

	Ex:

		new ArrayList<>()
		new ArrayList<>(collection type)
		new ArrayList<>(capacity)


String str=new String("apple") is it constructor? yes

Right click -> show Diagrams 

	summary of classes/packages


 4/9/2022

Day 42 Custom Classes

day42_custom_classes
____________________________________________________________

Custom Classes
____________________________________________________________

Continue practicing problem solving 
	3x problem a day
	automation
	soft skills

	hackerrank 
	leetcode

Talk about reversing a String

interview pdf

____________________________________________________________

What is a class?
	
	a template/blueprint for objects. It will have data and actions

	the class name must match the file name

What is an object?

	instance of a class - meaning a copy of the class

	each object has a copy of all the information in a class

What is an instance variable?

	variables made in a class

	these variables belong to the objects of the class
		-> Each object has its own copy of the variables

What is static?
	
	belongs to the class

	instance: object
	static: class

How to create an object?

	ClassName referenceName = new ClassName();

	instantiation: creating an object
		in-stan-shi-ation
____________________________________________________________

Example class and objects:

Student.java

		public class Student{
			
			String name;
			int batchNumber;
			int groupNumber;
			boolean inEveningBatch;

			public void study(){
				System.out.println("Studying");
			}

		}

Student is the class
name, batchNumber, groupNumber, and inEveningBatch are the instance variables 
study() is an instance method

Zoom.java

		public class Zoom {
			
			public static void main(String [] args){
				Student studentOne = new Student();
				studentOne.name = "James";
				studentOne.study();
			}
		}

Student studentOne = new Student(); this line is creating an object of the Student class
studentOne.name = "James"; this line is accessing the instance variable name from the studentOne object
studentOne.study(); this line calls the instance study() method from the studentOne

____________________________________________________________

How to print the objects

	by default if you try to print an object it will give some memory location

	Ex: 	Student obj = new Student();
			obj.name = "James";
			obj.batchNumber = 26;
			System.out.println(obj); --> memory location

	all classes have a method called toString which is automatically called when printing

	so if we made the toString method in the Student class:

		public String toString(){
			return name + " " + batchNumber
		}

	now if we print the object: 

		System.out.println(obj); -->  James 26

Shortcut:

	DO NOT WORRY ABOUT @OVERRIDE
	
	right click in the class -> generate option -> toString -> select the variables you want to include

	shortcut for generate window
		command + n (mac)
		alt + insert

Java prioritizes local variables

	if there is a local variable and an instance variable that have the same name the local variable is the one used

4/3/2022

Day 40 ArrayList

day40_arraylist
____________________________________________________________

ArrayList
____________________________________________________________

ArrayList

	a part of the collection framework

	Creating ArrayList objects

		ArrayList<type> name = new ArrayList<>();

			-> makes an empty ArrayList 

		ArrayList<type> name = new ArrayList<>( int );

			-> make an ArrayList with int number of capacity 

				size: how many elements there is 
				capacity: internal storage to be used
					default capacity is 10

		ArrayList<type> name = new ArrayList<>( collection type );		

			-> it will create an ArrayList with the values from the given collection type

			--> collection type: so far we only know ArrayList

				ArrayList<type> name = new ArrayList<>( ArrayList );	

		Q: Are array objects a collection type

			No, they are not in the collection framework, but we can use the Arrays utility class to help us convert an array into a collection type

				INVALID --> ArrayList<type> name = new ArrayList<>( array [] );	
				VALID 	--> ArrayList<type> name = new ArrayList<>( Arrays.asList( array []) );	

		Arrays.asList()
			parameters: array objects (var arg)
			return: collection type

			Note: this method is a var arg method, so we are able to type elements in the parenthesis and those will be taken as the array elements

	ex of var arg method

		normal: public static void method(int [] arr)
			to call this method you must give an array object

			int [] a = {4, 5, 1, 2};
			method(a)

		var arg: public static void method(int ... arr)
			to call this method you can either give an array object,
			or type the element values right away with commas

			int [] a = {4, 5, 1, 2};
			method(a)

			or

			method(4, 1, 5, 1);

More ArrayList methods:

	bulk operation methods:

		the arguments of these methods are collection types

		addAll(collection type): add all of the given collection type elements to the ArrayList
		removeAll(collection type): remove all the elements that match from the argument
		containsAll(collection type): checks if the ArrayList contains all of the defined elements from the argument
		retainAll(collection type): keep all matching elements from the argument. The rest are removed

Collections

	a utility class for collections

	located in the java.util package

	https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collections.html

	there is no sort method in ArrayList
		ArrayListObject.sort() is not valid

		ArrayObject.sort() is not valid

	Collections.sort(collection type): sort the given collection
		void method

	Collections.reverse(collection type): reverse the order of the elements in given collection	
		void method

	Collections.max(collection type): returns the biggest elements in the collection
		returns int

	Collections.min(collection type): returns the smallest elements in the collection
		returns int

	Collections.swap(collection type, index1, index2): swap the elements in the collection based on the defined indices. The element in index1 is put into the index2 and vice versa
		return void

	Collections.frequency(collection type, element): return how many times the given element is found in the collection
		returns int

 come back at 3:21 est

3/30/2022

Day 39 ArrayList

day39_arraylist
____________________________________________________________

Tomorrow: No Class
____________________________________________________________

ArrayList
____________________________________________________________

ArrayList methods:
	
	add(element) --> adds the element to the end of the ArrayList
		returns boolean

	add(index, element): puts the element at the given index number. All the other elements are moved over
		void

	get(index) --> returns the element at the given index

	size() --> returns how many elements the ArrayList has

		last index in ArrayList: name.size() - 1

	remove(index): removes the element at the given index number and returns that element value 
		-> what if you try to remove with an index that doesn't exist: it will go out of bounds

	remove(element): removes the given element and returns a boolean value if it was removed or not
		-> what if you try to remove with an element that doesn't exist: the list will not be changed and the method would return false

Iterating through an ArrayList

	ArrayList<Integer> nums = new ArrayList<>();
	nums.add(1);
	nums.add(2);
	nums.add(3);

	for(int i = 0; i < nums.size(); i++){
		System.out.println(nums.get(i));
	}

	or

	for(int each : nums){
		System.out.println(each);
	}

____________________________________________________________

Example of adding, removing

        ArrayList<String> list = new ArrayList<>();
        list.add("computer");
        list.add("screen");
        list.add("mouse");
        list.add("keyboard");

        String item = list.remove(0); // removes the first index of the ArrayList, which is (computer) and it returns that element (computer) from the method. We store the return value into a String variable called item
        System.out.println(item);
        System.out.println(list);

        boolean bool = list.remove("mouse");
        System.out.println(bool);
        System.out.println(list);

____________________________________________________________

More ArrayList methods:

	contains(element): check if the given element is in the ArrayList. Return boolean. True if the element is there or false if it is not

	clear(): remove all the elements in the ArrayList

		void: no return

	isEmpty(): return boolean. 
		true: whenever there is no element in the ArrayList
		false: whenever there is any element in the ArrayList

	set(index, element): replace the element at the given index number (1st parameter) with the given element (2nd parameter)

	indexOf(element): return an int
		first occurrence of the index of the given element

		if the element does not exist in the ArrayList: it returns -1

____________________________________________________________

Convert an Array to an ArrayList

	for array we were able to declare values using curly brackets

		int [] a = { 1, 2, 3, 4};

	We can't just do this for ArrayList

	But ArrayList can be made in other ways:

		ArrayList<type> name = new ArrayList<>(); // makes empty ArrayList, no elements

		ArrayList<type> name = new ArrayList<>( ArrayList object ); // make an ArrayList with a copy of the elements from another ArrayList

			--> this one is more generic: 
			ArrayList<type> name = new ArrayList<>( collection type );

	so

		we can use Arrays.asList() method which accepts an array parameter and return a collection type

	All the points combined:

		ArrayList<type> name = new ArrayList<>( Arrays.asList() );

		this will create a new ArrayList object by giving values into the asList method

Note: the asList method is a var arg method, which means the parameter is an array, but we can add the numbers ourselves using the element and a comma

	method(int ... nums) --> same as --> method(int [] nums)

	but the ..., the var arg method allow you to type the element in the parenthesis 



3/28/2022

Day 38 ArrayList

day38_arraylist
____________________________________________________________

ArrayList
____________________________________________________________

Recap

Wrapper Classes

	object representation of primitive datatypes 

	these classes are in the java.lang package

Converting types

	Autoboxing: converts the primitive datatype into an object type (Wrapper Class Objects)

	Unboxing: converts the object type into a primitive datatype

When to use Wrapper classes

	1) ArrayList and other collections can't work with primitive datatypes

	2) Useful methods, information 

		Ex: parse methods, MAX_VALUE

____________________________________________________________

ArrayList

	a class that works like a dynamic array that also has some methods

	located in the java.util package
		--> Anytime you want to use an ArrayList you must import it

	the size is flexible
	we can print the ArrayList objects normally 
	only work with Objects type --> primitive datatypes do not work 

	ArrayList will take more memory than an array
	Arrays itself is faster, whenever there is set of data that doesn't change

	Syntax:

		ArrayList<datatType> name = new ArrayList<>();

ArrayList methods:

	add(element): add the given element to the ArrayList at the end

		returns boolean --> returns true, but we don't normally use this return value

	add(index, element): adds the given element at the given index of the ArrayList. All elements are moved positions

	get(index): returns the element at the given index number

	size(): returns the number of how many elements the ArrayList has

	remove(index): remove the element at the given index and it returns the element that was removed
		all the elements move over

	remove(element): remove the given element from the ArrayList and it returns a boolean
		true -> remove an element
		false -> element doesn't exist




3/26/2022

Day 36 Overloading Methods

day36_methods
____________________________________________________________

Overloading methods
____________________________________________________________

Method overloading

How to have methods with similar idea, first we can try with different name:
but that means we would have to use so many more methods names

	ex:
		sumInt(int numOne, int numTwo)
		sumDouble(double, numOne, numTwo)
		sumString(String str, String str2)

	* method that has the same name, but different parameters

		-> allows us to have different methods, different code, but the same name

		overloading happens inside of a class, between methods

	ex:
		substring(start)
		substring(start, end)

		indexOf()

Q: Can you overload a method by changing the return type
	no, methods are overloaded by changing the parameters

Q: After you overload a method, can you change the return type
	yes, after a method is overloaded you can change the return type if you want


    public static void method(){
        System.out.println("default empty method");
    }

	// I will try to overload by changing the return type

	//    public static int method(){
	//
	//    }
	//    this is not valid, changing the return type does not overload

	public static int method(int a){
	        return 0;
	}

var args
variable arguments

	allow you to create methods that accept an array as the parameter, but we can type all the elements directly, separated by commas, without making an array object

	syntax: 

		normal --> 	(int [] nums)
		var args --> (int ... nums)

			ex:	method(element, element, element)

			public static int sum(int ... nums){

			call the method:
			System.out.println(sum(4, 6, 2, 6, 12, 4));

datatype promotion

	whenever you give an argument it will try to match with the specified type

	but if the type is not matched directly it will try to automatically promote to the closest type bigger than it

	byte --> short --> int --> long --> float --> double

	if there is no type available, then the code will not compile

summary:

Method overloading allows methods to be created with the same name
The parameters must be different (number of parameters, or the types of the parameters)
The return types should be the same, but if a method is overloaded it can be changed
Improve re-usability and readability 

____________________________________________________________

Git: Keep track of changes

project: B26_Git_Project

right click on project level -> new -> file -> .gitignore

What does the git ignore file do

	any files or folders in this file will not be tracked

Common java files to ignore:
.idea
*.iml
*.xml
/out

# comment with hashtag

-----------------------------------------------------------------
Scenario about versions 

	you do code in office hours
	office hours code was shared to the remote repository
	I wrote code in class
	try to share code to remote repository

		-> faced issue because my project was not the same as the project in the remote repository

	to fix the issue, I should update/or pull my project

		--> now my local repository is the same as the remote repository, so now I can commit and push my changes

	Monday class: 4.0
	Tuesday, office hours: 5.0
	Tuesday, in class: 4.0
		trying to share 4.0 --> 5.0 	
			x doesn't work

		to fix: I need to get version 5.0 to my computer --> update/pull

		now my computer has 5.0 version it means I can share the new code, which would share version 5.2


as a rule: you should always update your projects before pushing
-----------------------------------------------------------------

From the VCS option on the top we select enable version control system integration and pick git

	--> creates a local repository in this project
	--> VCS option becomes Git 

commit the changes so far, which was just the .gitignore

Went to Git option on the top -> Github -> share project

	1) creates a remote repository 
	2) links the local repository with the remote repository 
	3) pushes the first changes/commits

How to open the project on github?
right click on the project level --> open in --> github

created a new package day0
created a new class HelloWorld
wrote some code

commit -> selected the HelloWorld file
push from local repository to remote repository 

Note: The add option window was given to us about if we automatically want to keep track of all files
	if we cancel all files will be created un-versioned 
	if we add then all files will be tracked upon creation

created a new class called First
added some code/comments
commit those changes
go back to the First class and add more changes
commit those changes
after committing there was something wrong with commit message, so we edit it

	-> How to edit: right click on the commit in the git log and select edit commit message

	Note: If you pushed changes already you will not be able to change the commit message. It is not only local now

created the JamesBond.java file on github
	(create an idea that someone else made changes to the same remote repository)
wrote some code
commit the changes on the remote repository (save)
to get the changes from the remote repository to our local repository
	fetch: go the information without making any changes to our project

	Git -> fetch

	update: actually get the changes from the remote repository to our computer, which allows us to run the file now

	Git --> update



3/26/2022

Day 36 Overloading Methods

day36_methods
____________________________________________________________

Overloading methods
____________________________________________________________

Method overloading

How to have methods with similar idea, first we can try with different name:
but that means we would have to use so many more methods names

	ex:
		sumInt(int numOne, int numTwo)
		sumDouble(double, numOne, numTwo)
		sumString(String str, String str2)

	* method that has the same name, but different parameters

		-> allows us to have different methods, different code, but the same name

		overloading happens inside of a class, between methods

	ex:
		substring(start)
		substring(start, end)

		indexOf()

Q: Can you overload a method by changing the return type
	no, methods are overloaded by changing the parameters

Q: After you overload a method, can you change the return type
	yes, after a method is overloaded you can change the return type if you want


    public static void method(){
        System.out.println("default empty method");
    }

	// I will try to overload by changing the return type

	//    public static int method(){
	//
	//    }
	//    this is not valid, changing the return type does not overload

	public static int method(int a){
	        return 0;
	}

var args
variable arguments

	allow you to create methods that accept an array as the parameter, but we can type all the elements directly, separated by commas, without making an array object

	syntax: 

		normal --> 	(int [] nums)
		var args --> (int ... nums)

			ex:	method(element, element, element)

			public static int sum(int ... nums){

			call the method:
			System.out.println(sum(4, 6, 2, 6, 12, 4));

datatype promotion

	whenever you give an argument it will try to match with the specified type

	but if the type is not matched directly it will try to automatically promote to the closest type bigger than it

	byte --> short --> int --> long --> float --> double

	if there is no type available, then the code will not compile

summary:

Method overloading allows methods to be created with the same name
The parameters must be different (number of parameters, or the types of the parameters)
The return types should be the same, but if a method is overloaded it can be changed
Improve re-usability and readability 

____________________________________________________________

Git: Keep track of changes

project: B26_Git_Project

right click on project level -> new -> file -> .gitignore

What does the git ignore file do

	any files or folders in this file will not be tracked

Common java files to ignore:
.idea
*.iml
*.xml
/out

# comment with hashtag

-----------------------------------------------------------------
Scenario about versions 

	you do code in office hours
	office hours code was shared to the remote repository
	I wrote code in class
	try to share code to remote repository

		-> faced issue because my project was not the same as the project in the remote repository

	to fix the issue, I should update/or pull my project

		--> now my local repository is the same as the remote repository, so now I can commit and push my changes

	Monday class: 4.0
	Tuesday, office hours: 5.0
	Tuesday, in class: 4.0
		trying to share 4.0 --> 5.0 	
			x doesn't work

		to fix: I need to get version 5.0 to my computer --> update/pull

		now my computer has 5.0 version it means I can share the new code, which would share version 5.2


as a rule: you should always update your projects before pushing
-----------------------------------------------------------------

From the VCS option on the top we select enable version control system integration and pick git

	--> creates a local repository in this project
	--> VCS option becomes Git 

commit the changes so far, which was just the .gitignore

Went to Git option on the top -> Github -> share project

	1) creates a remote repository 
	2) links the local repository with the remote repository 
	3) pushes the first changes/commits

How to open the project on github?
right click on the project level --> open in --> github

created a new package day0
created a new class HelloWorld
wrote some code

commit -> selected the HelloWorld file
push from local repository to remote repository 

Note: The add option window was given to us about if we automatically want to keep track of all files
	if we cancel all files will be created un-versioned 
	if we add then all files will be tracked upon creation

created a new class called First
added some code/comments
commit those changes
go back to the First class and add more changes
commit those changes
after committing there was something wrong with commit message, so we edit it

	-> How to edit: right click on the commit in the git log and select edit commit message

	Note: If you pushed changes already you will not be able to change the commit message. It is not only local now

created the JamesBond.java file on github
	(create an idea that someone else made changes to the same remote repository)
wrote some code
commit the changes on the remote repository (save)
to get the changes from the remote repository to our local repository
	fetch: go the information without making any changes to our project

	Git -> fetch

	update: actually get the changes from the remote repository to our computer, which allows us to run the file now

	Git --> update



Day 35 Return Methods
day35_methods
____________________________________________________________
Method Practice
Utility Classes
____________________________________________________________
recap

return type method
a method: it has some code statement meant to be executed 
many times. It has some action
return type: some value will be given from the method

general syntax:
public static RETURN_TYPE methodName(){
}
creating a method with a return type, which means it is 
not void, there must be a return value given matching the datatype of the 
RETURN_TYPE
--> the value is returned from a method using 
keyword: return
when the return keyword is executed a value is passed 
from the method to where the method was called, and the method stops 
execution

How to call a method that is outside of the package?

1) import the class where the method is created
import packageName.className;
import: keyword
packageName: package where the file 
being used was created
className: class where the method you 
want to use is created

2) use the method by the class name
className.method()

Note: if you are in the same package you don't need to 
import
Note: if you are in the same class you don't need to put 
the class name part

How to import the whole package:
import packageName.*;
* is wildcard. It will import all classes in the defined package
Ex:
import java.util.*;
you can access Scanner or Arrays classes
plus many more

Shortcuts in IntelliJ
search for anything in IntelliJ: shift twice
command/control + shift + f: search for exact text in the files

==================================================================================================

3/23/2022
Day 34 Return Methods
day34_methods
____________________________________________________________
Return type methods
https://codingbat.com/java
Quizzes, check quizzes_and_assignments channel
Arrays Short quiz - Tonight
Unit 2 Assessment - Opening Friday
Saturday: java/git
Sunday: java
____________________________________________________________
Recap: Methods
a group of statements that have some action and those actions become 
re-usable anywhere in the project
2 types of methods:
void: executes some action, but it doesn't give any 
information/value back
public static void methodName(){
}
return: execute some actions, and it returns some value
public static RETURN_TYPE methodName(){
}
parameters:
allowing the method to get some data/information to use 
inside of the method
parameters are defined in the parenthesis of a method
--> to add multiple parameters use a comma 
and define:
datatype name, datatype name, etc
any parameter is local to that method
ex:
charAt(index)
charAt(0)
charAt --> method name
(index) --> parameter, some information 
of this type must be given to run the method
(0) --> the 0, or any other number 
given, is the argument - the actual value that will be used in the method 
code
____________________________________________________________
return type
public static RETURN_TYPE methodName(){
}
method that does an action, but it will return/give back 
a single value
RETURN_TYPE: any type
these method use the keyword:
return
-> this keyword with values is how we will 
get information out of the methods
the return keyword also stops the method, because a value 
was passed out of it already
Debugging method
instead of step over, select step into in on the method line, select 
which method you want to debug

====================================================================================================

3/20/2022

Day 33 Void Methods

day33_methods
____________________________________________________________

Void Methods
____________________________________________________________

Recap

	1D Single Dimensional Arrays

		int [] nums = {1, 2, 5}
		String [] words = {"a", "b", "c"}


	2D Array

		array inside of an array - the elements were arrays

		int [][] n = { {2, 3, 5, 6}, {1, 5, 123, 51} };

		n[0] --> {2, 3, 5, 6}
		n[1] --> {1, 5, 123, 51}

		n[0][0] --> 2
		n[0][1] --> 3
		n[0][2] --> 5
		n[0][3] --> 6

		n.length --> 2

		n[0].length --> 4

	loop through 2d array

	for each

		for(int [] arr : n){
			// this loop goes through the 2d array. The elements are arrays

			for(int number : arr){
				// this loop goes through each inner array, which will see each number

			}

		}

	traditional

		for(int i = 0; i < n.length; i++){
			// this loop goes through the 2d array. The elements are arrays
			// to access each array element --> n[i]

			for(int j = 0; j < n[i].length; j++ ){

				// this loop goes through each inner array, which will see each number
				// to access every inner element --> n[i][j]

			}
		}

declaring 2D array

	datatType [][] arrayName = new dataType[x][z];

		where x is how many elements the 2D array has - number of arrays

		where z is the size of each inner array
			-> is optional to define. If it is not defined then the inner arrays sizes do not matter, they can be different

	datatType [][] arrayName = { arrayName1, arrayName2, etc}

	dataType [][] arrayName = { {element, element, element, etc}, {element, element, element, etc}, {element, element, element, etc} };

Q: Why is it giving NullPointerException
String [][] str = new String[2][];  // [ null, null ]
        str [0][0] = "str"; // no array yet, this code will cause problems

       String [] a = {"element", "element"};
       str[0] = a;

       str[1] = new String[]{"element", "element"}

String s = null;
s.charAt(0); --> null.charAt(0) --> NullPointerException

____________________________________________________________

Methods

	a code block that has reusable code

	There is ready methods from java: String methods, Arrays class methods, Scanner method, etc
		-> Code already written and is used by programmers

	We can create our own custom methods, which means we can create reusable code. After writing a method we can call/use the method anywhere in the project

	in other language you may hear function, but in java they are call methods

	Ex:

		public static void hello(){
			System.out.println("Hello");
		}

		public --> access modifier, allows us to call the method in the whole project
			-> Until we say or see anything else, we will use public or our methods

		static --> allows us to call the method by the class name

			className.method()

			-> in the same file, you don't need to give the class name

		void --> no return value. The method will execute some code, but no value is going to come out of it

			Ex: Arrays.sort()

		hello() --> name of the method
			-> Names should be clear about the action of the method

	main method: a special method that is executed when the code is run 

	custom method: will not run by themselves, we have to call/use them somewhere

Parameters:

	to allow our methods to have input we are able to defined parameters

	if a method has a parameter then a value must be given into order to call the method

		-> parameter: name inside of the method

		-> argument: value given to call the method

	the parameters are local variables in the method

		-> the variables cannot be used outside of the method

	you can have multiple parameters by using a comma to separate them 

	there is no restriction to the types, to the number of parameters

	Ex:

		printNumber(int n)  --> method has an int parameter that will be references by the n variable

		to use this method:

		printNumber(5) --> when calling the method an int type value must be given, and that is called the argument


=================================================================================================

3/19/2022

Day 32 Multidimensional Arrays

day32_array
____________________________________________________________

Arrays Class
Multidimensional arrays
____________________________________________________________

Arrays Class

	utility class for arrays. Has useful methods/action for array objects

	Ex: int [] n = { 5, 1, 4};


	Arrays.toString(): printing array objects

		Arrays.toString(n) --> [5, 1, 4]

	Arrays.sort(): rearrange elements to be in order of smallest to largest
		-> for String elements: Lexicographical

		Arrays.sort(n) --> [1, 4, 5]

	Arrays.equals(): compare two array objects to see if they have the same elements

		int [] a = {1, 4, 5};
		int [] b = {1, 4, 5, 6};

		Arrays.equals(n, a) --> true   | Remember we sorted the n array
		Arrays.equals(a, b) --> false

String methods:
	
	String.join(): allows the array to be separated by a certain character/s

		String.join("*", n) --> 1*4*5

	--> method works for String array types

____________________________________________________________

More Arrays Class

	Arrays.copyOf()

		two arguments:

			(array, size)

				array: the array you want to copy the elements from
				size: the size of the new array

	Arrays.binarySearch()
		find/search for the position of an element in the array

		--> in order for the method to work, the array must be sorted

		two arguments:
			
			(array, element)	

				array: the sorted array you are checking in
				element: the element you are trying to find the index/position of

		if the element you are looking for is not in the array, then it returns a negative number based on where the position would be + 1

____________________________________________________________		

Multidimensional Arrays

	Array inside of an array. The elements of a 2D array is a single dimensional array

	single dimensional array:

		int [] a = {1, 2, 3};

	2D array:

		int [][] arr = {

			{1, 2, 3},
			{4, 5, 6}

		}

		arr[0] --> {1, 2, 3}
		arr[1] --> {4, 5, 6}

		How to access the first element of each inner array

			arr[0][0] --> 1
			arr[1][0] --> 4

	How to print multi dimensional arrays

		Arrays.deepToString()

	int [][][] 
		3D array --> elements are 2D --> 1D array


3/16/2022

Day 31 Arrays

day31_array
____________________________________________________________

Arrays Class
____________________________________________________________

String Methods with Arrays

	toCharArray(): convert a String to a char array, where each elements is every character from the the String

	split(): convert a String to a String array, where each element is the sequence of characters between the given separator

____________________________________________________________

Arrays Class

	https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html

	a class that has methods for arrays

	located in the java.util

		-> so to use this class you must import java.util.Arrays;

	Methods:

		Arrays.toString(arr): allowed us to print arrays objects as a String

			--> array is the argument

			Ex:
				String [] s = {"a", "b", "c"};
				Arrays.toString(s) --> [a, b, c]


		Arrays.sort(arr): sort the elements in ascending order (smallest to largest)

			--> array is the argument

			does not return anything

			for String/character types: lexicographical, means order in ascii table

				special characters --> number --> uppercase (A-Z) --> lowercase(a-z)

				aaa, aab aac

			--> this method does not have a return(nothing to store), it will sort the object
				array object are mutable, you can change the object after making
					-> The size is fixed

		Arrays.equals(arr, arr2): checks if the two given arrays are equal - they have the same elements

			--> two array argument
			--> returns boolean

String method: 

	String.join()

		two arguments:
			String: which characters you want to separate, or be in between the elements 
			array: the data structure where the elements come from

		lets you convert the array object to a String using a different format. You able to define the sequence of characters that will separate the element from the array



3/14/2022

Day 30 Arrays

day30_arrays
____________________________________________________________

String methods:
    toCharArray()
    split()
____________________________________________________________

for each loop

    a loop used to iterate through a collection/data structure 

        there is many collections, right now we are using arrays

    it will always iterate through the elements from the beginning to the end

    syntax:

        for(datatype name : array){

        }


        datatype is the type of each element in the array


        name: represent every element during the execution
            in traditional loop the way to get every element is using array[i]


    When to use for each

        - whenever you need to check each element of your array

        - whenever you need to only read values, meaning no values in the array will be changed

    When not to use for each

        - whenever you need to use indexes 

        - whenever you would need to change the array

____________________________________________________________

String methods that are related to arrays

    toCharArray()
        no arguments
        returns a char []

        --> converts the String to a char array

            Ex:
                String s = "abc";
                s.toCharArray() --> [ 'a', 'b', 'c' ];

Note: String class works with char [] internally

    - converting a char [] to a String: 

        using the new String approach of creating an array and giving the char [] as the argument

        ex:
            char [] arr = {'z', 'y', 'x'};

            String str = new String(arr); // "zyx"

    split(): 
        String argument 
        returns a String []     

    --> converts the String into a String [] by separating the String into different parts, which become the elements of the String

    -> the delimiter/separator is not included as an element. This determine how the String will be split it

    most common use case:

        convert a sentence to an array, where every word is an element

        Ex:

            String str = "Today is Monday";
            String [] words = str.split(" ")  --> [Today, is, Monday]

            words[0] --> Today
            words[1] --> is
            words[2] --> Monday

    if you split by empty space
        it returns back a String [] of each character in the String

        Ex:
            String s = "abc";

            s.split("") --> [ "a", "b", "c"];


3/13/2022

Day 29 Arrays

day29_array
____________________________________________________________

Array
for each loop
__________________________________________________________

Array: a data structure that holds multiple pieces of information 

	2 ways to make arrays

		datatype [] name = { elements, elements, elements};

		int [] a = { 1, 2, 3, 4, 5};

	or

		datatype [] name = new datatype[size];

		int [] b = new int[5];

		--> When you create an array this way, an empty array is made with default values based on your datatype

			String --> null
			int --> 0
			double --> 0.0
			boolean --> false
			char --> '\u0000' // don't worry about it so much

Read elements from an array

	name[index]  --> gives back the element

Assign/reassign elements in an array

	name[index] = value;

Printing the whole array

	the array object cannot be printed directly in the print statement

	we must use Arrays.toString() method which accepts an array as an argument and returns a String format of our array 

How to iterate through an array

	name[i]   where i is an int number in some loop that will go up by one

__________________________________________________________

For Each Loop

	used with data structures/collections

	so we know arrays

	syntax:

		for(datatype variableName : array/collection){

		}

		action: the loop will iterate through the array on the right side of the colon.
				it goes from the first element to the last elements always
				each iteration the element value will be used in the loop as the variableName defined 

		datatype in the loop declaration is the type of the elements

		ex:

			int [] arr = {10, 20, 30};

			for(int num : arr){
				System.out.println(num);
			}

			iteration 1:
				num would be 10, prints 10

			iteration 2:
				num would be 20, prints 20

			iteration 3:
				num would be 30, prints 30


		traditional loop vs for each loop iteration: 

			array[i] is the same as num in the for each loop

	When should you use for each:

		- if you want to iterate through all the elements

		- read the values

	When can you not use for each:

		- use indexes: to change/update a variable dynamically 
	
		- modify the array in any way

3/12/2022

Day 28 Arrays

day28_array
____________________________________________________________

Array
for each loop
____________________________________________________________

Array: a data structure, which is a collection of data in one object

	Before we had normal variables that stored one piece of information at a time 

	In programming working with multiple data is very common

	Arrays are objects

How to create arrays

	there is two ways to make an array

	1) datatype [] arrayName = { element, element, element };

		able to make an array with initial elements. These elements are given between the curly brackets. Each element is separated by a comma

		Ex:

			String [] cities = { "Chicago", "New York" , "Houston", "Denver", "Pittsburgh" };

			int [] nums = { 1, 2, 3, 4};

	2) datatype [] arrayName = new datatype[size];

		able to make an array of a certain size. These elements have a default value. There is elements created for each position made in the array

		Ex: String [] cities = new String[5]; [ null, null, null, null, null ]

			int [] nums = new int[4]; [0, 0, 0, 0]

			boolean [] bool = new boolean[2]; [false, false]

		Default values for array types

			String --> null
			int --> 0
			double --> 0.0
			boolean --> false

		Q: What is the difference between null and "" (empty space)

			null means nothing, for objects
			empty space is a String, but it has no characters

			Scanner input = null; // no actually Scanner object

	Note: 

		int [] name
			vs
		int name []

		both make an array, but the brackets in the middle are preferred 

How to read/use elements from an array

	using the name of the array and the index number you are able to use that element

	arrayName[index] --> gives back the element

How do you know the number of elements

	using the length value

	arrayName.length --> gives back how many elements there is

	Q: What is the difference between length() and length

		length() is a String method to return the number of characters

		length is an array property that returns the number of elements

	Q: How can you access the last element

		last index --> length - 1

		arrayName[ arrayName.length - 1 ]

How to print all the elements in the array

	by default print an array:
		System.out.println(arrayName)

		will show the hash location of the object in the memory

	We must use the Arrays class

		Arrays class is a utility class, which has some useful methods

			in order to use a class we need to import it:
				import java.util.Arrays;

		Arrays.toString() --> returns a String format of the whole array

		System.out.println(Arrays.toString(arrayName));

How to assign/reassign elements in an array

	arrayName[index] = value;

Looping through an array

	in for loop:

		arrayName[i] 

			where i is a variable declared in the loop that iterates 1 index at a time

			
3/9/2022

Day 27 Nested Loops

day27_nested_loops
____________________________________________________________

nested loop
__________________________________________________________

Nested Loop

	a loop inside of another loop

	ex:

		//outer loop
		for(int i = 0; i < 5; i++){


			// inner loop
			for(int j = 0; j < 2; j++){

			}

		}

		the outer loop will execute for 5 times

		every iteration of the outer loop will execute the inner loop from beginning to end 

			so, how many times total does the inner loop run? 10 times

		i: 0
			j: 0
			j: 1
		i: 1
			j: 0
			j: 1
		i: 2:
			j: 0
			j: 1
		i: 3:
			j: 0
			j: 1
		i: 4:
			j: 0
			j: 1
__________________________________________________________

continue and break in nested loops

	whichever loop the continue or break statements are in is the one that gets effected


3/8/2022

Day 26 Nested Loops

day26_nested_loops
____________________________________________________________

nested loop
____________________________________________________________

Nested Loops

	loop inside of a loop

	ex:

		// outer loop
        for(int week = 1; week <= 4; week++){  

            System.out.println("Week: " + week);

            // inner loop
            for(int day = 1; day <= 7; day++){
                System.out.println("\tDay: " + day);
            }

        }


        outer loop: first loop that has another loop inside of it
        	- determines how many executions of the code you want inside of this block

        	- in our example: we wanted to run for 4 times, because there is 4 weeks 

        inner loop: loop inside of another one

        	- treat this as a normal loop that will be executed from beginning to end EACH ITERATION OF THE OUTER LOOP

        	- in our example it means the days will go from 1 to 7 for every week


No Day 25 Notes

3/6/2022

Day 24 Loops

day24_loops
____________________________________________________________

for loop
break and continue statements
__________________________________________________________

Recap

	while/do while: when the number of iterations is not known, it is based on other factors

	for loop: used when the number of iterations is fixed/known

	for(initialization; termination condition; update){

		statements
	}

	--> for syntax each section is optional. You must have the semi colon

		for( ; ; ) --> infinite loop

		for(int i = 0 ; i < 5 ; ) --> infinite loop

		for(int i = 0 ; ; i++ ) --> infinite loop

	flow of the for loop:

		1) initialization: declare and assign a variable that is used in the loop. Usually used to keep track of the number of iterations. Other use of the variable can be done, for example using the number as an index of a String

			--> this runs once, in the beginning

		2) termination condition: the boolean that determines if you should run/continue the loop

			if the boolean is true: the statements in the loop will execute 

			if the boolean is false: the loop stop


		3) the code in the loop body is executed - this is one iteration of the statements

		4) update: changes the variable to avoid infinite loop

		5) going back up to step 2 - iteration is complete, next cycle will start

Strings with loops

	Q: What does a loop iterating through a String loop like

		for(int i = 0; i < s.length(); i++){


		}

		These are possible ways to write the termination condition:

		i < s.length();
		i <= s.length() - 1;

			ex: String s = "java"
					i < s.length();  i < 4   --> stop before 4 because it is not a valid index
					i <= s.length() - 1; i <= 3  --> stops at the last index of 3

		--> indexes start from 0, so our loop value i is set to start at 0, then it updates by 1 each iteration. The loop will continue as long as the number i is less than the length, which means the loop will only used valid index numbers

	Q: What does a loop look like if you go backward in the String

		for(int i = s.length() - 1; i >= 0; i--){


		}

		--> we start our loop from the last index of the String. To get the last index of a String we can use the length - 1. Then the loop will update by subtracting 1 each iteration as long as the number is more than or equal to 0, because those are the valid index numbers

	Q: How to dynamically read each character

		s.charAt(i)

			where i is the variable name declare in the loop

intellij shortcut: fori


	break statement in loop:

		stops and exits the loop

	continue statement in loop:

		it will skip the rest of the iteration and goes to the update part. 
		any code after a continue will not run for that iteration


		ex: 

        for(int i = 1; i <= 100; i++){

            if(i % 2 == 1){
                continue;
            }

            System.out.print(i + " ");

        }


3/6/2022

Day 24 Loops

day24_loops
____________________________________________________________

for loop
break and continue statements
__________________________________________________________

Recap

	while/do while: when the number of iterations is not known, it is based on other factors

	for loop: used when the number of iterations is fixed/known

	for(initialization; termination condition; update){

		statements
	}

	--> for syntax each section is optional. You must have the semi colon

		for( ; ; ) --> infinite loop

		for(int i = 0 ; i < 5 ; ) --> infinite loop

		for(int i = 0 ; ; i++ ) --> infinite loop

	flow of the for loop:

		1) initialization: declare and assign a variable that is used in the loop. Usually used to keep track of the number of iterations. Other use of the variable can be done, for example using the number as an index of a String

			--> this runs once, in the beginning

		2) termination condition: the boolean that determines if you should run/continue the loop

			if the boolean is true: the statements in the loop will execute 

			if the boolean is false: the loop stop


		3) the code in the loop body is executed - this is one iteration of the statements

		4) update: changes the variable to avoid infinite loop

		5) going back up to step 2 - iteration is complete, next cycle will start

Strings with loops

	Q: What does a loop iterating through a String loop like

		for(int i = 0; i < s.length(); i++){


		}

		These are possible ways to write the termination condition:

		i < s.length();
		i <= s.length() - 1;

			ex: String s = "java"
					i < s.length();  i < 4   --> stop before 4 because it is not a valid index
					i <= s.length() - 1; i <= 3  --> stops at the last index of 3

		--> indexes start from 0, so our loop value i is set to start at 0, then it updates by 1 each iteration. The loop will continue as long as the number i is less than the length, which means the loop will only used valid index numbers

	Q: What does a loop look like if you go backward in the String

		for(int i = s.length() - 1; i >= 0; i--){


		}

		--> we start our loop from the last index of the String. To get the last index of a String we can use the length - 1. Then the loop will update by subtracting 1 each iteration as long as the number is more than or equal to 0, because those are the valid index numbers

	Q: How to dynamically read each character

		s.charAt(i)

			where i is the variable name declare in the loop

intellij shortcut: fori


	break statement in loop:

		stops and exits the loop

	continue statement in loop:

		it will skip the rest of the iteration and goes to the update part. 
		any code after a continue will not run for that iteration


		ex: 

        for(int i = 1; i <= 100; i++){

            if(i % 2 == 1){
                continue;
            }

            System.out.print(i + " ");

        }


3/2/2022

Day 22 Loops

day22_loops
____________________________________________________________

while loop
do while loop
____________________________________________________________

Recap

	Ternary
		types need to match
		type s = boolean (type) ? (type)

	Loops

		repeating some code statements multiple times

	while loop: repeat some code statements using a boolean value. 

		usually used when the number of iterations are not defined.  

		flow/execution order of while loop:

			1) checks the boolean expression

				-> when the boolean is true:

					execute the statements inside of the while block (inside of the curly brackets), top to bottom

					the loop goes back to step 1)

				-> when the boolean is false:

					the loop stops. the code resume execution from after the loop

	iteration: one cycle/execution of the code

	infinite loop: the loop continues to run, with no stop

		-> in while loop it means the boolean will never be false, it stays always true

		avoid infinite loops


do while

    similar to the while loop but the first iteration/execution always happens no matter the boolean expressions 

    do{

        // statements

    } while(boolean_expression);


3/1/2022

Day 21 Loops

day21_loops
____________________________________________________________

Loops introduction
while loop
__________________________________________________________

[Middle char]
	Given a String, write a program to display the middle character of a string
	a) If the length of the string is even there will be two middle characters. b) If the length of the string is odd there will be one middle character.
	Ex:
	Input: elephant
	Output: The middle characters: ph

__________________________________________________________

Loops

	Loops in programming are used to repeat statements multiple times

	Loop types: 

		while loop, do while loop, for loop, for each loop

	while loop: loop that continues to run as long as the boolean value is true

	syntax:

		while(boolean_expression){

			// statements that are repeated

		} // while loop ending point

	while loop execution flow:

		boolean expression is checked

			-> if the boolean is true

				the loop will run, which means the code inside of the while loop are executed top to bottom

				then it goes back up to check the boolean expression again

			-> if the boolean is false: the loop will stop

	infinite loop: a loop that will continue to run, over and over again without stopping. The boolean will never be false

	iteration: each cycle of the loop. The statements are run each time you iterate


Factorial 
	5! = 5 * 4 * 3 * 2 * 1

	120

2/28/2022

Day 20 String Practice

day20_string
___________________________________________________________________

Recap

	general syntax to use methods: 	stringObject.method()

	Index: a number position. Every character in a String has an index
		indexes start from 0

		String s = "apple";
					01234

	charAt(int index): returns the character at the given index
		ex:	s.charAt(0) --> 'a'
			s.charAt(3) --> 'l'
			s.charAt(6) --> StringIndexOutOfBoundsException	

				-> If you use any index that is not valid you will get the exception/error

	indexOf(): returns the index (int) based on the given argument

		(char): return the index where the given char is found in the String. It returns the first occurrence of that character

			ex:
				s.indexOf('a') --> 0
				s.indexOf('p') --> 1
				s.indexOf('z') --> -1

					-> When a char is not found in the String, it returns -1

		(String): returns the index of the character sequence in the String. It returns the index where the sequence starts

			ex:
				s.indexOf("ppl") --> 1
				s.indexOf("le") --> 3
				s.indexOf("pear") --> -1
				s.indexOf("a") --> 0

		(char, int): it returns the index of the given char, but it starts looking at the given int index number

				ex:
					String a = "applep"
								012345
					a.indexOf('p', 2) --> 2
					a.indexOf('p', 3) --> 5

		(String, int)

	lastIndexOf(): returns the index (int) based on the given argument, but it checks from the end of the String

		ex:

			s.lastIndexOf('p') --> 2

	substring(): returns part of a String based on the arguments

		(int): return the String characters starting from the given index (starting point) until the end of the String. This given index is included in the resulting String

			Ex:

				String str = "monday";
							  012345

				str.substring(3) --> day
				str.substring(1) --> onday
				str.substring(10) --> StringIndexOutOfBoundsException

		(int, int): returns the String characters from the first argument (index) until the second argument (index). The first index is included in the resulting String, but the second index is not included (the stopping point)

				String str = "monday";
							  012345

				str.substring(2, 5) --> nda
				str.substring(2, 6) --> nday
				str.substring(2, 7) --> StringIndexOutOfBoundsException

		these two code do similar thing

		s.charAt(0)  -> gives char type

		s.substring(0,1) -> gives String type

how to convert any type to String

	concatenate a space

	usually empty space ""


        // ( "" + firstName.charAt(0)).method --> this will also give you the first character, but as a char type


    replace(): allows you to change a certain character/s to another character/s. Replaces all occurrences of those characters in the String

    	(char, char): first char is the value you are trying to change and the second char is the value you are changing it to 

    		Ex:
    			String a = "apple";
    			a.replace('p', 'z') --> azzle

    	(String, String): first String is the value you are trying to change and the second String is the value you are changing it to

    		String str = "today is monday";
    		str.replace(" ", "") --> todayismonday

    		str.replace("monday", "tuesday") -> today is tuesday

    replaceFirst(): replaces the first occurrence of the characters


2/27/2022

Day 19 String

day19_string

____________________________________________________________

Recap

String methods:

    general syntax: stringObject.method()

    equals(): checks if the Strings value/objects have the same characters
        -> cares about case sensitivity

        returns boolean

    equalsIgnoreCase(): checks if the String value/object have the same characters, but it ignores case sensitivity

        returns boolean

    length(): checks and returns the number of characters

        -> spaces are characters

        returns int

    toUpperCase(): converts all the characters in the String to uppercase letters

        returns String

    toLowerCase(): converts all characters in the String to lowercase letters

        returns String

    startsWith(""): checks if the String starts with the characters given in the parenthesis

        returns boolean

    endsWith(""):  checks if the String ends with the characters given in the parenthesis

        return boolean

    contains(""): checks if the String has the given character sequence in it

        returns boolean

    isEmpty(): checks if your String has characters or not. If there is no characters, it is empty

        return boolean

    isBlank(): checks if your String has non white space characters or not. If there is only white spaces it is blank

        return boolean

    trim(): removes spaces in the beginning and end
        -> spaces anywhere between other characters are not removed

        return String

____________________________________________________________

Indexes

    every character in a String has a position where it is located called an index

    index numbers start from 0

    Q: How can I find the last index of a String

        length - 1

        Why does that work? Because index starts from 0

    method(_______)  <-- when you give some information in the parenthesis of a method it is called an argument

    charAt(index): returns the character at the given index number

        returns char

    substring(): returns part of a String

        (int): the returned String starts from the given index number until the end of the String.

        (int, int): the returned String starts from the first given index number until the second given index number. The first index is included, but the last index is not included in the characters

        Ex: 
        String s = "abc";
        s.substring(1) --> bc

    indexOf(): returns the index number of the given char/String argument

        returns int

        -> if you try to find a character that does not exist in the String, the method will return -1

        (char): it will find the first occurrence of the given character in the String and returns the index of that character

        (String): it will find the first occurrence of the given character sequence (String) and it returns the index of the first character of that sequence

        (char/String, int): it will find the char/String (first argument) in the String starting from the index of the second argument

Later:

    lastIndexOf()

    replace()

    replaceFirst()

2/26/2022

Day 18 String

day18_string
____________________________________________________________

Recap
String class
__________________________________________________________

String 

	String is a class, so we make objects to use it

		-> holds multiple characters 

	the class is found in the java.lang package

		-> is imported automatically 

2 ways to create String objects

	1) String literal: using double quotations with nothing else
		Ex: String s = "Saturday";

		-> made in the String pool

	2) new keyword: new String("");
		Ex: String s = new String("Saturday");

Memory

	Stack: references (variable name)

	Heap: objects (variables), String pool

	String pool: a special memory location for String literals. It saves memory by not having to make Strings over and over again 

String is immutable: String objects cannot be changed after being created


--> to compare Strings we should never use == 

	== with Strings compare the objects to each other

String methods:

	general syntax: stringObject.method()

	equals(): checks if the Strings value/objects have the same characters
		-> cares about case sensitivity

		returns boolean

	equalsIgnoreCase(): checks if the String value/object have the same characters, but it ignores case sensitivity

		returns boolean

	length(): checks and returns the number of characters

		-> spaces are characters

		returns int

	toUpperCase(): converts all the characters in the String to uppercase letters

		returns String

	toLowerCase(): converts all characters in the String to lowercase letters

		returns String

	startsWith(""): checks if the String starts with the characters given in the parenthesis

		returns boolean

	endsWith(""):  checks if the String ends with the characters given in the parenthesis

		return boolean

	contains(""): checks if the String has the given character sequence in it

		returns boolean

	isEmpty(): checks if your String has characters or not. If there is no characters, it is empty

		return boolean

	isBlank(): checks if your String has non white space characters or not. If there is only white spaces it is blank

		return boolean

	trim(): removes spaces in the beginning and end
		-> spaces anywhere between other characters are not removed

		return String

__________________________________________________________

ask the user to enter a message
clean the message for empty spaces in the beginning and end
check the message for bad phrases:
	
	java is bad
	quit
	have fun
	crying

if there is a bad phrase in the message print:
	
	message failed to send

otherwise print:

	$message sent


2/23/2022

Day 17 String

day17_string
____________________________________________________________

String class
Start String methods
____________________________________________________________

String

	String is a class 
		the class is in package: java.lang	
			-> java.lang is automatically imported 

	-> Scanner class was in java.util

	Strings are object types, not primitive data types
		object types (non primitive)

	immutable: cannot change it

	-> in java: an immutable object cannot be changed after it is made. The value cannot be changed

	Memory 

	in general: 
		hard drive storage - where you store data

		ram: memory used by the computer

		Stack: variable names/reference 

		Heap: objects are stored

			String pool:
				located in the heap

				it is a special memory location for String literals

	2 ways to create String objects

		- String literal

			just giving double quotations

		- new keyword

			using new String("value");


Q: What is the difference between == and .equals()

	== compares the objects in the memory

	.equals() compares the value, meaning the characters 


String methods:

	equals():	compares two Strings and give a boolean
		it gives true if the String characters are exactly the same. 

	equalsIgnoreCase(): compare two Strings and given a boolean
		it gives true if the String characters are the same characters, while ignoring case sensitivity 

	length(): gives an int of how many characters are in the String

		Q: Are spaces characters: yes. Counts as a character for the length method


2/22/2022

Day 16 Review

day16_review
________________________________________________________________

review

multi branch/ternary - retake

nested if - movie ticket
nested if - soccer game

switch - calculator 
switch - author
switch - hotel

extra:
casting
operators
________________________________________________________________

Switch

	control flow statement that allows us match values via cases. Checks if the given value is equal to any defined case 

	switch(value){

		case possible_value: 
			// statements
			break;
		default:
			// statements

	}

	case possible_value: expected value that you are checking equality with. Datatype matches the value datatype
 
		valid datatypes: byte, short, int, String, char

		invalid datatypes: float, double, boolean, long

		cannot have duplicates cases. cases must be unique

	break: stops the switch statement

	default: case that is executed if no other case matches

		it be anywhere in the switch 

	Execution flow:

		takes the value and tries to match it with a case. If the case is there, the statements are executed from that point, top to bottom, until the end of the switch or a break statement

	What is the difference between if, switch, and ternary

		if statements:
			in most cases if statements are used for controlling the flow of a program

			work with boolean logic

			able to use all datatypes

			multiple types that handle multiple different scenarios


		switch statements:
			can only compare values, check if the values are equal

			when the cases are known, when there is a fixed number of exact possible values


		ternary:

			used sometimes when there is simple boolean logic and a value must be given back
				the value is usually assigned to a variable or used right away

				- cannot be used when there is only one possible outcome

		any switch or ternary can be converted to an if statement
________________________________________________________________

Todo:

	Short videos:
		
		String Intro
		String Methods Part 1
		String Methods Part 2
		String Methods Part 3


2/20/2022

Day 15 Switch Statements

day15_switch
____________________________________________________________

switch statements
____________________________________________________________

Switch

conditional statement: controlling the program 

	switch statements only compare exact values ==

		-> relational operators ( > < >= <= !=) are not allow in switch

	switch(variable) {

		case x:
			// statements
			break;

		default:

	}

	switch: keyword to make a switch statement

	variable: value being checked/compared in the switch
		on these types are allowed as the input variable: byte, short, int, char, String

		which means these types are not allowed as the input variable: float, double, long, boolean

	case: value that you are checking for. The datatype of the case should match the datatype of the variable being checked

	statements: any code you want to run when the case matches

	break: stops and exits the switch statement

	default: case when no other cases match

		example:

			int a = 3;

			switch(a) {

				case 1:
					// statements
					break;
				case 2:
					// statements
					break;
				case 3:
					System.out.println("Three");
					break;
			}

	Execution Flow

		if statements: go top to bottom. Checks each condition one at a time until a condition is true or there is no more conditions

		switch statement: the case matches first, then the statements are executed, top to bottom, from that case until the end of the switch or break key-words.


Declare: price and calories variables

Ask the user to enter which size drink they want

Based on the drink size determine the price and calories of the order

	data:

		size: tall
		price: 2.50
		calories: 100

		size: grande
		price: 4.00
		calories: 150

		size: venti
		price: 4.50
		calories: 200



2/19/2022

Day 14 Nested If statements

day14_if_statements
____________________________________________________________

nested if statements
__________________________________________________________

Warm Up 
[Pandemic Checker]

Write a program that will read a number from the user. This number will be a year. Use that given year to figure out if there was a pandemic in that year, and if there was which one. 

	Data to use:
		1346-1353: The Black Death
		1665-1666: Great Plague of London
		1770-1772: Russian plague
		1889-1890: Flu pandemic
		1916: American polio epidemic
		1918-1920: Spanish Flu 
		2009-2010: H1N1 Swine Flu pandemic
		2014-2016: West African Ebola epidemic
		2020-2022: COVID-19
		Any year not in those ranges: No Pandemic
__________________________________________________________

Nested if statements
	
	if statement inside of if statement

	if( 1 ) {

		if( 2 ){
			A
		}

	} else {

		if( 3 ){
			B
		} else {
			C
		}	

	}

	 1       2
	true	true  	--> A
	false	true	--> goes to else
	true    false	--> nothing happens, there is no else


	1 		3
	false 	true	--> B
	false	false	--> C


Format the code
	
	windows: control + alt + l
	mac: command + option + l

inputs:
declare and assign a 4 digit pin code
declare and assign the last 4 digits of ssn: 1234

declare and assign expected values for both
	example expected:
		pin: 1552
		ssn: 1234

outputs:
	
	when the pincode and ssn match the expected print:
		Authentication successful

	when the pincode or ssn are not correct print:
		Authentication failed

	when the pincode was not correct print:
		incorrect pin code

	whent he ssn is not correct print:
		invalid ssn 


2/16/2022

Day 13 If statements

day13_if_statements
____________________________________________________________

multi branch if statements
if without brackets
ternary
__________________________________________________________

Recap

	Q: When to use multi branch statements: 
		when you have multiple conditions that you want to check and when those statements are related to each other

	if (condition) {
		// if the condition is true, this code will run
	} else if(condition 2){
		// if the condition 2 is true, this code will run
	} else if(condition 3){
		// if the condition 3 is true, this code will run
	} else {
		// if all the conditions were false, then this code will run
	}

	Q: How many else if can you have
		as many as you want

	Q: How many else can you have
		only one at the end

	Q: Is else block mandatory 
		no, it possible to have just single if statement

	Multi branch if statements will execute top to bottom like other code, the condition will be checked and if there is a true condition that code block will be executed and if statement will be done

	Q: What if there is more than 1 true statement
		since the code goes from top to bottom, the first true statement will decide which code block will be run

	single if vs multi branch

		single if: for each if statement each condition is checked

			if(){

			}

			if(){

			}

		multi branch: each if condition will be checked, until there is a true result

			if(){

			} else if(){

			}

__________________________________________________________

if statements without brackets

	you can create if statements without brackets

		with brackets:

			if(4 > 5){
				System.out.println("hello");
			}

		without brackets:

			if(4 > 5)
				System.out.println("hello");

	when there is an if statement without brackets, only the line after it is the if block
	without brackets, you cannot have more than one line of code in that if block

	suggestion: don't be lazy, always use brackets

__________________________________________________________

Ternary 

	a way to write an if statement quickly

	syntax:

		resultVariable = boolean_expression ? trueValue : falseValue;

			? -> if, but it comes after boolean

			: -> else

	ex:
		int score = 90;

		if(score > 75){
			System.out.println("pass");
		} else {
			System.out.println("fail");
		}


		-------

		int score = 90;
		String result;

		if(score > 75){
			result = "pass";
		} else {
			result = "fail";
		}

		System.out.println(result);

		-------
		int score = 90;
		String result;

		result = score > 75 ? "pass" : "fail";


short videos
	sat: nested if
	sun: switch


2/15/2022

Day 12 If statements

day12_if_statements
____________________________________________________________

if statements 
if/else statements 
multi branch if statements
__________________________________________________________

Recap

	single if statement:

		if(boolean_expression){
			// statement
		}

		if the boolean expression is true, then the code in the if block will be run
		if the boolean expression is false, not code is executed 

	if else statement

		if(boolean_expression){
			// statement
		} else {
			// statement
		}

		if the boolean expression is true, then the code in the if block will be run
		if the boolean expression is false, then the code in the else block will be run
__________________________________________________________

What is debugging:
	to find the reason of your issue/error in the code, you are able to check line by line

Debug:
	
	1) create a breakpoint by clicking on the gray bar next to the code lines

	2) click the on the green run button, but select the debug option

	3) then to progress from line to line you can click the step over button (execute 1 line at a time)

	4) Debugger window/ Console: you can swap between the windows to see the console and the debugger information

__________________________________________________________


2/14/2022

Day 11 If statements

day11_if_statements
____________________________________________________________________

if statements 
if/else statements 
____________________________________________________________________

Control Flow Statements

	code that allows you to control how your program runs

	if statements:

		single if statement

		if / else statement

		multi branch if statement if/ else if / else

		nested if

	single if

		if(boolean_expression){
			// statements
		}

		when the boolean expression is true -> the statements inside of the if block will be executed

		when the boolean expression if false -> nothing will happen, the code will resume execution after the if statement

	if else 

		if(boolean_expression) {
			// statements for if block
		} else {
			// statements for else block
		}

		when the boolean expression is true -> the statements inside of the if block will be executed

		when the boolean expression is false -> the statements inside of the else block will be executed

	What is the difference between the single if statement and the if else statement?

		For both the if block is executed if the boolean is true

		but when the boolean is false

			single if: nothing happens

			if else: else block runs
____________________________________________________________________

Format the code

	Mac: Command + Option + L

	Windows: Control + Alt + L

Sharing code in discord

```
code

```
2/13/2022

Day 10 Scanner

day10_scanner
____________________________________________________________

Scanner
Practice
__________________________________________________________

Recap

Scanner 

	hard code: values directly in the code

		ex: int a = 450; // 450 is hard coded

		ex: String url = "www.google.com";

	dynamic values: value that come from outside of the code
		ex: Scanner, website, db, file

		ex: int b = SCANNER CODE;

	Scanner is a class that allows us to get values from the console. The Scanner methods allow us to type into the console and depending on the method, we are able to get different datatypes.

	class: java file, has methods and variables. Non primitive datatype

	method: group of code, has some functionality 

		ex: nextInt() method allows us to type a number in the console and save it to a variable or use it

	How do you use the Scanner and its methods

		1) import the class

			to use a file from a different package we must import the file we want to use

			general syntax:

				import package name.class name;

				popular names for Scanner: scan, input, scanner, keyboard

			for Scanner:

				import java.util.Scanner;
			
			-> imports go between the package and the class

					PIC: order of the java file content: package, import, class

			-> What about String?

				String class is in a different package, how are we using it?

				package: java.lang is automatically imported

		2) make a Scanner object (declare a Scanner variable)

				syntax:

					Scanner name = new Scanner(System.in);


				-> only declared once in each class

		3) use the Scanner methods with the name you declared

			ex:

				name.method()

				Scanner methods:

					nextByte()
					nextShort()
					nextInt()
					nextLong()
					nextFloat()
					nextDouble()
					nextBoolean()

					next(): gives you a String, but it only accepts one word

					nextLine(): gives you a String, but it allows multiple words. This method also accepts enter inputs


				problem:

					whenever we use nextLine() method after any other Scanner methods the input is consumed by the enter from the previous input

				solution:

					add an extra nextLine() just to handle the enter input, then you can use nextLine() to read a String value

__________________________________________________________

Short videos this week:

	If Statements: Single If
	If Statements: If & Else
	If Statements: Multi Branch If
	If Statements: Nested If
	Ternary
	Switch Statement

	more replit added
		[B] Print Variable 4
		[B] Print Variable 5
		[B] Print Variable 6
		[B] Phone Number
		[B] Time 
		[B] Print Variable 7
		[I] Add Numbers
		[A] Patient Information
		[A] Seconds Converter

	variables short quiz solution on canvas


2/12/2022

Day 9 Logical Operators & Scanner

day09_scanner
____________________________________________________________

Recap
Logical Operators
Precedence of all operators
Scanner class
____________________________________________________________

Todo:

	- get ready to move away from okta
	- quiz due by tonight 11:59 EST

____________________________________________________________

Recap

	Shorthand Operators
		+=
		-=
		*=
		/=
		%=

	Relational Operators
		statements return a boolean value

		>
		<
		>=
		<=
		== 
		!=
____________________________________________________________

Right click -> refactor -> rename

Logical Operators

	I want to do this:

		5 < num < 10 --> cannot do this in java

	Evaluate/compare two boolean expressions and result in a boolean value

	one comparison and one comparison -> result

		num > 5 AND num < 10

	AND Logic

		&&

		both expressions need to be true for the result to be true

	OR logic

		||

		at least one expressions to be true for the result to be true

	NOT logic

		!

		opposite boolean value

	short circuit: more efficient. if the output of the expression is known the other condition is not executed  

		&& AND checks if both boolean expressions are true.
			If the first expressions is true it checks the second one for true to get a result of true
			If the first expression is false then the second expression is not executed at all 

		|| OR checks if both boolean expressions are true. 
			If the first expressions is true it doesn't execute the second 					expressions
			If the first expression is false then the second expressions is executed  


		& 		execute both expressions not matter what
		|		execute both expressions not matter what
____________________________________________________________

Scanner

	Scanner is a CLASS that has METHODS that allow us to get input values from the console

	classes are java files 

	methods are a block of code that is ready to use. do/have actions

	Why do we use Scanner?
		To avoid hard coded information, we want to use/get information from outside of the code

	How can you use Scanner

		1) import the class 

				allow us to use a different class/file that are in different packages

				for Scanner: import java.util.Scanner;

			-> imports go between the package and class
					PIC: package, import, class

			-> you must import to use Scanner


		2) 	creating the Scanner object(variable)

			object allows us to use the methods

			syntax:

				Scanner nameOfScanner = new Scanner(System.in);

		3) use the methods

			to use the actions that are defined we can use Scanner method with the object we made (step 2)

				general syntax:
					nameOfScanner.method()


				methods:

					nextByte()
					nextShort()
					nextInt()
					nextLong()
					nextFloat()
					nextDouble()
					nextBoolean()

					String types:

					next() : one word
					nextLine(): multiple words

____________________________________________________________

2/12/2022

Day 9 Logical Operators & Scanner

day09_scanner
____________________________________________________________

Recap
Logical Operators
Precedence of all operators
Scanner class
____________________________________________________________

Todo:

	- get ready to move away from okta
	- quiz due by tonight 11:59 EST

____________________________________________________________

Recap

	Shorthand Operators
		+=
		-=
		*=
		/=
		%=

	Relational Operators
		statements return a boolean value

		>
		<
		>=
		<=
		== 
		!=
____________________________________________________________

Right click -> refactor -> rename

Logical Operators

	I want to do this:

		5 < num < 10 --> cannot do this in java

	Evaluate/compare two boolean expressions and result in a boolean value

	one comparison and one comparison -> result

		num > 5 AND num < 10

	AND Logic

		&&

		both expressions need to be true for the result to be true

	OR logic

		||

		at least one expressions to be true for the result to be true

	NOT logic

		!

		opposite boolean value

	short circuit: more efficient. if the output of the expression is known the other condition is not executed  

		&& AND checks if both boolean expressions are true.
			If the first expressions is true it checks the second one for true to get a result of true
			If the first expression is false then the second expression is not executed at all 

		|| OR checks if both boolean expressions are true. 
			If the first expressions is true it doesn't execute the second 					expressions
			If the first expression is false then the second expressions is executed  


		& 		execute both expressions not matter what
		|		execute both expressions not matter what
____________________________________________________________

Scanner

	Scanner is a CLASS that has METHODS that allow us to get input values from the console

	classes are java files 

	methods are a block of code that is ready to use. do/have actions

	Why do we use Scanner?
		To avoid hard coded information, we want to use/get information from outside of the code

	How can you use Scanner

		1) import the class 

				allow us to use a different class/file that are in different packages

				for Scanner: import java.util.Scanner;

			-> imports go between the package and class
					PIC: package, import, class

			-> you must import to use Scanner


		2) 	creating the Scanner object(variable)

			object allows us to use the methods

			syntax:

				Scanner nameOfScanner = new Scanner(System.in);

		3) use the methods

			to use the actions that are defined we can use Scanner method with the object we made (step 2)

				general syntax:
					nameOfScanner.method()


				methods:

					nextByte()
					nextShort()
					nextInt()
					nextLong()
					nextFloat()
					nextDouble()
					nextBoolean()

					String types:

					next() : one word
					nextLine(): multiple words

____________________________________________________________

2/8/2022

Day 7 Unary & Shorthand Operator

day07_unary_operators
____________________________________________________________

Recap
Operator Precedence
Unary Operators
____________________________________________________________

Recap

	replit difficulty

		B - beginner
		I - Intermediate
		A - Advanced 

	Arithmetic Operators

		+ - * / %

		Calculations when there is different datatypes: The result is the bigger datatypes

			int * int -> int
			int * double -> double
			float * long -> float
			short * byte -> int 

			-> Whenever we use short or byte, they will be turned to int during the calculation, so the result is given as int

		parenthesis group statements together
____________________________________________________________

Unary Operators

	+ 	(plus) positive number
	-	(minus) negative number
	++	incrementing, adding 1
	--	decrementing, subtracting 1

	int num = 0;

	pre-increment: increment the value before the rest of the statement is run

		++num

	pre-decrement: decrements the value before the rest of the statement is run

		--num

	post-increment: increments the value after the statement is run

		num++

	post-decrement: decrements the value after the statement is run

		num--


	int x = 50;

	x = x + 5;

	x? 55

	----------

	int a = 10;
	int b = a + 2;

	a? 10
	b? 12

what is the difference between ( ++ X) and (X= X+1)
	the result is the same

	the ++X can be used in the middle of a statement, with other code

        int i = 5; // i = 6
        int z = ++i; // z = 6

        System.out.println(i);
        System.out.println(z);

2/7/2022

Day 6 Arithmetic Operators

day06_arithmetic_operators
____________________________________________________________

Recap
Arithmetic Operators
Operator Precedence
____________________________________________________________

Short videos this week

	Arithmetic Operators
	Unary Operators
	Short hand Operators
	Relation operators
____________________________________________________________

Recap

	char

		a single character in a single quote ' '
		every character has a number related to it

	boolean

		true or false

	String

		multiple characters in double quotations " "

		concatenation: whenever anything/any type is concatenated with a String, the result becomes a String and the two data are put together

		String is not a primitive datatype. its a class

	Type casting

		changing the datatype from one to another

		order:  [SMALL] byte -> short -> int -> long -> float -> double [LARGE]

		Smaller datatype --> Larger datatype	
			Widening convention happens automatically

			int --> double

		Larger datatype --> Smaller 
			Narrowing convention happens manually

			double --> int

		Formula to cast:
			datatype variable = (datatype you are casting to) variable/value

			Data loss: sometimes when going from a bigger number to a smaller number or a decimal number to a whole number there can be data loss, which means the value is changed

		char <> int

------------------------------------------------------------
Create a class House
    create a main method

    - Each the datatype you feel is most appropriate for each variable. 

    - Create the following variables:
        house type, number of bedrooms, number of bathrooms, number of kitchens, is there a basement?, is there an attic, is there a pool, is the house for sale?, cost of the house, address, zipcode, is a park near by, Rating of surrounding school districts (out of 5), 

    - Print each variable with a message with the value
        Ex: The number of bedrooms is: 4
            The number of bathrooms is: 3

------------------------------------------------------------
____________________________________________________________

Number 
	1.0E7 
	1.0 x 10^7 
____________________________________________________________

Arithmetic Operators

	+ addition
	- subtraction
	* multiplication
	/ division
	% remainder/modulus

	When you use arithmetic operators between two different datatypes the result will be the bigger type.

	- When you use datatypes like short or byte and use some arithmetic operators the values are changed to int, so the result of the operation is also int

____________________________________________________________


2/6/2022

Day 5 Variables

day05_variables
____________________________________________________________

Recap
char
boolean
String
primitive casting
____________________________________________________________

Recap

	What are variables?

		container/storage that holds information/data/values

		-> Why do we need variables: improves re-usability, reduces repetitive code. Also it makes easier to change the information

		-> Can you store a variable in another variable: it will assign the value from the first variable to the other one

	How to declare variables

		Create a container that can store data and you clarify the type of data that it will store. Must declare before using it. Creates the variable name that is used to access the data.

		-> How do you access variables: you give the variable name, with no quotations

		- syntax:

			dataType variableName

			int age;

	How to assign to variables

		Puts a value(data/information) into a variable using the assignment operator =

		- syntax:

			variableName = value

			age = 10;

	How to declare and assign variables

		Instead of creating the variable and storing information into the variable at separate time, it is done at the same time

		- syntax:

			dataType variableName = value

	Naming rules for variables

		use any letter (A-Z or a-z)
		contains numbers (0-9), but can't start with a number
			can have: age2
			cannot have: 2age
		special characters: dollar sign $ and underscore _
		no reserved words
		no spaces
		cannot have repeating names, names must be unique
		should follow camel case:
			starts with lowercase and every other word in the name should start with a uppercase

	How to reassign

		change the value in a variable. Updates the value

	How to concatenate variables with characters

		add a group of characters in double quotations with a variable using the plus operator + 

		When you concatenate with a String, the result is a String

	What are the datatypes types

		in java there is primitive datatypes and non primitive types

		- we will learn non primitive later

		what kind of information

	What are primitive datatypes

		whole numbers (Integers)
			byte
			short
			int 		<- default type by compiler
			long

		floating numbers (Decimal numbers)
			float
			double		<- default type by compiler

		character
			char : holds a single character

				-> each character is represented in a single quote 'a'

			unicode: character have numbers related to them
				ASCII - part of unicode

		boolean

			boolean: true or false statements

	Non primitive datatype

			String
				not a primitive datatype. Class

				holds multiple characters using the double quotations

				concatenations vs addition
					String + String -> concatenation
					String + number -> concatenation
						values of the String and number type are combined, output value is String
					String + char -> concatenation
						values of the String and a char are combined, output value is String
					number + number -> addition 
					char + char -> addition 

				Q: What is the difference between 'a' and "a"

					the types are different. The 'a' is a char type and the "a" is a String type

____________________________________________________________

Task

	create a class MyName
	create a main method
	create multiple char variables, one for each letter of your name
	print your name 
		print each letter in a different line
		print your name in the same line

____________________________________________________________

Task

	create a class CellPhone
	create a main method
	declare and assign these variables:
		brand, model, color, price, storage, hasCamera, sim(char A, B, C)

	Print all the variables

		sample data: apple, iphone 10, black, 1000.99, 128, true, A

____________________________________________________________

Task

	create a class EmployeeInfo
	create a main method
	declare and assign these variables:
		first name, last name, gender, age, company name, are the full time, job title, salary, number of pto (0-25), are they married, suite(char - A, B, C, D)

	Print all the variables
____________________________________________________________

	In numbers you can use underscore to make the number more readable

	java doesn't allow you to type commas in number

		Example:
			1,000,00

			java: 1_000_000

____________________________________________________________

Type casting

	Convert from one primitive datatype to another

		- going from a smaller datatype to a bigger datatype happens automatically

				int i = 40;
				long l = i;

		- going from a bigger datatype to a smaller datatype needs manually casting

				long l = 100;
				int i = (int) l;


		Casting Formula:
				smallerDatatype varName = (smallerDatatype) biggerDatatypeValue

____________________________________________________________

2/5/2022

Day 4 Variables Intro

day04_variables
____________________________________________________________

Recap
Variable declaration and assignment
Variable naming rules
Primitive datatypes

Replit
____________________________________________________________

Recap

	Comments

		text directly in the code, it is used to explain the code, have reminders of what it does

		does not get executed

		-> When there is an issue in the code, we can comment out the code as well

		types:

			// single line comment - comments one lines

			/* multi line comment - comments multiple lines */

			/** java docs comment - comments multiple lines with more functionality */

		TODO: allows you to create a reminder, intellij has a built in feature to show all todo comments

	Escape Sequences 

		allows to use certain characters that are also part of java syntax

		\'	'
		\"	"
		\\	\
		\n	new line
		\t	tab
____________________________________________________________

Shortcut to comment

command/control + /

____________________________________________________________

Variables

	container to hold data/information

	allow the values of information to changed, used multiple times

	Declare a variable: makes a container/variable ready to be used

		dataType variablName;
		int age;

	Assign a value to a variable: store some value/number into your container

		variableName = value;
		age = 10;

	Declaring and assigning at the same time

		dataType variableName = value;
		int age = 10;

DataTypes

	In java there is many types. 

	Primitive datatypes: byte, short, int, long, float, double, boolean, char

	Object types: (we will spend more time on this later)
		-> String

	-> all primitives are lowercase

		whole numbers: (ex: 40)
			byte
			short
			int   <- by default
			long
		floating numbers: (ex: 24.62)
			float
			double  <- by default

	-> compiler uses int and double by default

	How to tell the compiler you want long number: use an 'L' at the end of the number
	How to tell the compiler you want float number: use an 'F' at the end of the number

concatenation

	we can use + to add variables to characters, to make a message

reassigning

	changing the value something else, old value is lost. Updating the variable


Q: Can you write numbers starting with 0
	
	no, it becomes a different number
	for whole numbers

Hardcoded: directly in the code, so it is difficult to change

shortcut for printing variables: soutv

Need to talk about:
floating numbers
concatenation
reassigning
variable naming rules

class name Olympics

create a variable for the year
print the country and year for next couple events
reassign year value each time. Country name is hard coded

data:
	
	China 2022
	France 2024
	Italy 2026

Look forward to the year $year for the Olympics to be in $location

Task:

	class name: School

declare and assign these variables
	number of students in grade 1
	number of students in grade 2
	number of students in grade 3
	number of students in grade 4
	number of students in grade 5

	total number of students in your school

	number of days in a year (have some half day = ~ 100.5)
	number of snow days in a year (double)
	average gpa in school (3.5) [ranges 1.0 - 4.0]

	print all of the variables with unique messages

____________________________________________________________

Variable naming rules

	- make the variable names are clear as possible
		dont do:

			int x;
			int a;

	- Variables can contains these:
		- any letter (A-Z, or a-z)
		- any number (0-9)
		- only special characters allowed are dollar sign $ and underscore _

	- for multiple words: use camel case.
		each new word starts with an uppercase

			words: today is saturday
			camel case: todayIsSaturday
			Pascal case( class names) TodayIsSaturday

	- don't use reserved words

	- Can't start with a number
		int 1age --> invalid
		int age1 --> valid

____________________________________________________________

Summary:

	What are variables?
	How to declare variables
	How to assign to variables
	How to declare and assign variables
	How to reassign
	How to concatenate variables with characters
	What are primitive datatypes
	What are the default types

____________________________________________________________


2/2/2022

Day 3 Comments & Escape Sequence

day03_comments_escape_sequence
____________________________________________________________

Recap
Comments
Escape Sequence
Using Github
____________________________________________________________

Short videos for the weekend:
	
	Primitive Data Types
	Primitive Type Casting
____________________________________________________________

Warm up:

	- Create todays package: day03_comments_escape_sequence

	- Create a new class in todays package: Goals

		- Create a main method

		- Using print statements print out 3 different goals you have for yourself in this course. Print each on a different line

____________________________________________________________

Recap

If you don't have group: 
	Omer#9709
	Guljannat#2209

	Canvas

	IntelliJ

		project: folder where all the other files are in

		src: source folder, where we will write java code

		package: folders in src, that will organize/group code

		java class: .java file that will have java code

		main method: a place to write and run code

			code: public static void main (String [] args) {}

			shortcut in Intellij: main

		console: window that shows the output of your code

		out: folder that stores your bytecode. DO NOT TOUCH

	Print statements

		Code: System.out.println();

			this allows us to output something to the console

		How do we print letters/characters: double quotations ""

		shortcut in Intellij: sout

	- Java is case sensitive
	- Java is not space sensitive

	How to change the name of something:

		right click -> refactor -> rename
____________________________________________________________

Github

	See all the code we do together, online

	Go to okta -> click the github enterprise button -> Java Programming Project -> src -> package -> code

____________________________________________________________

println() vs print()

	System.out.println(); 

		prints whats given to the console. Then goes to the next line

	System.out.print();	

		prints whats given to the console, but all in the same line

		-> Cannot be used without input

____________________________________________________________

Comments

	in our java files we can write comments which are just text that will not be executed(run)
		-> compiler ignores these lines because they are not code

	Comments are used to explain the code. Creates notes, reminders

	Comments helps with documentation 

	Q: When you use comments do you need quotation marks: No, because it is not code

Types of comments

	- Single line comments: comments everything in that line

		syntax: 

			// comments this whole line

	- multi line comments:  allows us to write multiple lines of text

		syntax:

			/*
				any number of lines 
				can be be put between
				the syntax
			*/

	- Java doc comments: similar to multi line comments, so it allows you to write comments in multiple lines, but this provides extra function for html documentation

		syntax:

			/**
			*
			*
			*/

	- TODO: allows you to create reminders. IntelliJ has separate window to keep track of all the todos on the bottom left corner

	view -> tool windows -> todo

____________________________________________________________

Escape Sequence

Q: How can you output this:

		I like "java" programming

We can use the backslash to define a character we want to output
	
	\

	for example: if we want to output a " quotation mark we can do:
		\"

	for example: if we want to output a \ backslash we can do:
		\\

	some more useful escape characters:

		code 	-> output
		\" 		-> "
		\\ 		-> \
		\'		-> '
		\n 		-> next line
		\t 		-> tab

	- Escape sequences are using in quotations

____________________________________________________________

Todo: 
	
	watch short videos
	practice tasks
	get good sleep on Friday


2/1/2022

Day 2 Intellij & Print Statements

day02_print_statements
____________________________________________________________

Intellij Set Up
Print Statements
First Java Program
____________________________________________________________

Recap:

	What do computer understand:
		binary (0s and 1s)

	input -> [process/algorithm] -> output

	algorithm: step by step of how to solve the problem

	code (high level) -> compile/interpret (translates) -> machine level (low level)

	File.java -> compiler -> File.class (bytecode) -> JVM will translate and run

		-> Where does the compiler come from: JDK

		-> Whats the point of having the middle step of bytecode: it means you ran run java code anywhere there is a JVM (Platform independent)
____________________________________________________________

Project name: Java_Programming_B26

By default all projects are made in a folder called IdeaProjects
	
	this folder is under your user


IntelliJ project components

	project name: Project folder

	src: source folder

	package: folder

	class: java file

	console: window that shows your outputs

	out: folder that has the bytecode

	IntelliJ saves automatically

Class: HelloWorld
	no space

Java is not space sensitive  (in the code)
Java is case sensitive (the lowercase and uppercase letter matter)

What is this

	public static void main (String [] args) {
		

	}

	-> main method: allows you to run code

	-> When do you make main method: in every class, every separate file in only have one main method

What is this

	System.out.println();  

	-> lets your output something to console


We use quotation marks to display characters

	is space a character -> yes

Task: 	create a new java file called: TellMeAboutYourSelf under day2 package

		add a main method

		try and print your name

Shortcuts:

	main method: main or psvm

	printing: sout


How to rename things
	for packages, for classes

	right click -> refactor -> rename

Task:
	
	add more code to TellMeAboutYourself

		try to add more lines that print:

			- where you live
			- a hobby you enjoy
			- a random number

Task:
	
	create a class called MyTriangle under the day 2 package

	try to print a triangle

		 *
		* *
	   *****

Naming conventions
	
	package: lowercase, no spaces. to separate words you can use underscore. 
		periods/dot for sub package

	class: Pascal Case - Words are together with no spaces, Each word starts with uppercase letter

		words: today we learned java


		normal: todaywelearnedjava

		camel case: todayWeLearnedJava
			first letter is lowercase and the rest of the words start with an uppercase

		Pascal Case: TodayWeLearnedJava

Github: place where we will store code

Todo:

	Make sure you have github access on okta, if you don't contact support

	Finish watching the rest of the short videos
		Single line & multi line comments
		Escape Sequences

	A little practice with making classes, main method and print statements


1/31/2022

Day 1 Introduction to Programming
____________________________________________________________

Get Started
____________________________________________________________

Short videos for this week:

	Creating Java Project
	Main Method & Print statements
	How Java works
	Single line & multi line comments
	Escape Sequences
____________________________________________________________

Saim (dime)

Discord:

	general: off topic

	class chat: during class

	q&a: where you ask your questions

	saim_only

	create_a_ticket: contact support

Schedule
	
	Friday: off

	M T W S SU: technical days
	TH: soft skills with Nadir

		Weekdays: 7 pm - 10 pm
		Weekends: 10 am - 5 pm

Class flow:

	45 - 50 minutes (review/recap)
	15 minute break
	45 - 50 minutes
	15 minute break
	45 - 50 minutes

What im using: Sublime text

____________________________________________________________

binary:
	language that the computer understands

	made of 0s and 1s

ASCII: American Standard Code for Information Interchange

	every character has a number related to it

	A -> 65

How do you represent 5 as binary?
	
	101 == 5

	011 == 3

What is an algorithm?
	
	step by step solution to a problem

pseudocode: step by step solution what the code should do, but it isn't code. It is in English 

How does a computer understand our needs/action

	We write high level code (human understandable)

	Translated: compile / interpret

	Turns to low level code so computer can understand (machine level)

Java can be used in many ways, but our focus is on automation

Where do programmers write code?
	
	any text file

	IDE: integrated development environment 

		-> a tool to help us write code

		we will use IntelliJ

How does java work:
	
	write code 		-> 	compile 	-> bytecode
	(.java)								(.class)

	bytecode runs in the jvm. The jvm translates to binary		

Symbols:

	{ } curly brackets
	[ ] square brackets
	( ) parentheses
	 ;  semi colon

File:  stores some data

extensions:

	.doc
	.pdf
	.ppt
	.png
	.img
	.txt

	.java
	.class

What is the different between JDK, JRE, JVM

	JDK: Java development kit	
		allows you to write java code
		contains the JRE and JVM, and compiler

	JRE: Java runtime environment
		contains JVM, JRE libraries(files), which allows java code to be run

	JVM: Java virtual machine
		runs the java code
		interprets

____________________________________________________________

Typing:
	typing.com
	typeracer
	ztype

Shortcuts:

			mac / windows
	
	copy: command/control + c

	paste: command/control + v

	cut: command/control + x

	undo: command/control + z

	save: command/control + s

	screenshot: 

		mac:
			command + shift + 5

		windows:
			windows key + shift + s
____________________________________________________________

Keywords from today:

	binary, ascii, algorithm, pseudocode, IDE, bytecode, compiler, high level/lower level, syntax

	syntax: grammar for code
____________________________________________________________

For tomorrow:

	- make sure you have java installed
		use the command: java -version
			command prompt (windows) / terminal (mac)

	- IntelliJ - jetbrains toolbox

	- Short videos
		Creating Java Project
		Main Method & Print statements
		How Java works



